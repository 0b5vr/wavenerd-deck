{
  "version": 3,
  "sources": ["../src/index.ts", "../node_modules/@0b5vr/experimental/src/algorithm/binarySearch.ts", "../node_modules/@0b5vr/experimental/src/algorithm/traverse.ts", "../node_modules/@0b5vr/experimental/src/array/arrayRange.ts", "../node_modules/@0b5vr/experimental/src/array/arraySerial.ts", "../node_modules/@0b5vr/experimental/src/array/arraySet.ts", "../node_modules/@0b5vr/experimental/src/array/constants.ts", "../node_modules/@0b5vr/experimental/src/array/utils.ts", "../node_modules/@0b5vr/experimental/src/CDS/CDS.ts", "../node_modules/@0b5vr/experimental/src/Clock/Clock.ts", "../node_modules/@0b5vr/experimental/src/Clock/ClockFrame.ts", "../node_modules/@0b5vr/experimental/src/Clock/ClockRealtime.ts", "../node_modules/@0b5vr/experimental/src/color/colorFromAtariST.ts", "../node_modules/@0b5vr/experimental/src/math/utils.ts", "../node_modules/@0b5vr/experimental/src/color/colorHSV2RGB.ts", "../node_modules/@0b5vr/experimental/src/color/colorToHex.ts", "../node_modules/@0b5vr/experimental/src/math/vec/vecDot.ts", "../node_modules/@0b5vr/experimental/src/color/colorTurbo.ts", "../node_modules/@0b5vr/experimental/src/color/eotfRec709.ts", "../node_modules/@0b5vr/experimental/src/color/oetfRec709.ts", "../node_modules/@0b5vr/experimental/src/dag/dagEdgesParents.ts", "../node_modules/@0b5vr/experimental/src/dag/dagEdgesAncestors.ts", "../node_modules/@0b5vr/experimental/src/dag/dagEdgesChildren.ts", "../node_modules/@0b5vr/experimental/src/dag/dagEdgesDescendants.ts", "../node_modules/@0b5vr/experimental/src/dag/dagEdgesParent.ts", "../node_modules/@0b5vr/experimental/src/dag/dagEdgesResolve.ts", "../node_modules/@0b5vr/experimental/src/edt/edt.ts", "../node_modules/@0b5vr/experimental/src/ExpSmooth/ExpSmooth.ts", "../node_modules/@0b5vr/experimental/src/Pool/Pool.ts", "../node_modules/@0b5vr/experimental/src/GPUTimer/GPUTimer.ts", "../node_modules/@0b5vr/experimental/src/HistoryMeanCalculator/HistoryMeanCalculator.ts", "../node_modules/@0b5vr/experimental/src/HistoryMeanCalculator/HistoryPercentileCalculator.ts", "../node_modules/@0b5vr/experimental/src/HistoryMeanCalculator/HistoryMedianCalculator.ts", "../node_modules/@0b5vr/experimental/src/MapOfSet/MapOfSet.ts", "../node_modules/@0b5vr/experimental/src/math/vec/vecAbs.ts", "../node_modules/@0b5vr/experimental/src/math/vec/vecAdd.ts", "../node_modules/@0b5vr/experimental/src/math/vec/vecDivide.ts", "../node_modules/@0b5vr/experimental/src/math/vec/vecLength.ts", "../node_modules/@0b5vr/experimental/src/math/vec/vecLengthSq.ts", "../node_modules/@0b5vr/experimental/src/math/vec/vecManhattanLength.ts", "../node_modules/@0b5vr/experimental/src/math/vec/vecMultiply.ts", "../node_modules/@0b5vr/experimental/src/math/vec/vecNeg.ts", "../node_modules/@0b5vr/experimental/src/math/vec/vecScale.ts", "../node_modules/@0b5vr/experimental/src/math/vec/vecNormalize.ts", "../node_modules/@0b5vr/experimental/src/math/vec/vecSub.ts", "../node_modules/@0b5vr/experimental/src/math/vec/Vector.ts", "../node_modules/@0b5vr/experimental/src/math/vec4/vec4ApplyMatrix4.ts", "../node_modules/@0b5vr/experimental/src/math/vec3/vec3ApplyMatrix4.ts", "../node_modules/@0b5vr/experimental/src/math/quat/quatInverse.ts", "../node_modules/@0b5vr/experimental/src/math/quat/quatMultiply.ts", "../node_modules/@0b5vr/experimental/src/math/vec3/vec3ApplyQuaternion.ts", "../node_modules/@0b5vr/experimental/src/math/vec3/vec3Cross.ts", "../node_modules/@0b5vr/experimental/src/math/vec3/vec3OrthoNormalize.ts", "../node_modules/@0b5vr/experimental/src/math/vec3/Vector3.ts", "../node_modules/@0b5vr/experimental/src/math/box3/box3ContainsPoint.ts", "../node_modules/@0b5vr/experimental/src/math/box3/Box3.ts", "../node_modules/@0b5vr/experimental/src/math/mat3/mat3FromMat4Transpose.ts", "../node_modules/@0b5vr/experimental/src/math/mat3/mat3Inverse.ts", "../node_modules/@0b5vr/experimental/src/math/mat3/mat3CreateNormalMatrix.ts", "../node_modules/@0b5vr/experimental/src/math/mat3/mat3Determinant.ts", "../node_modules/@0b5vr/experimental/src/math/mat3/mat3FromMat4.ts", "../node_modules/@0b5vr/experimental/src/math/mat3/mat3FromQuaternion.ts", "../node_modules/@0b5vr/experimental/src/math/mat3/mat3Multiply.ts", "../node_modules/@0b5vr/experimental/src/math/mat3/mat3Transpose.ts", "../node_modules/@0b5vr/experimental/src/math/mat3/Matrix3.ts", "../node_modules/@0b5vr/experimental/src/math/mat4/mat4FromQuaternion.ts", "../node_modules/@0b5vr/experimental/src/math/mat4/mat4Compose.ts", "../node_modules/@0b5vr/experimental/src/math/mat4/mat4Determinant.ts", "../node_modules/@0b5vr/experimental/src/math/quat/quatFromMatrix3.ts", "../node_modules/@0b5vr/experimental/src/math/quat/quatFromMatrix4.ts", "../node_modules/@0b5vr/experimental/src/math/mat4/mat4Decompose.ts", "../node_modules/@0b5vr/experimental/src/math/mat4/mat4FromMat3.ts", "../node_modules/@0b5vr/experimental/src/math/mat4/mat4Inverse.ts", "../node_modules/@0b5vr/experimental/src/math/mat4/mat4LookAt.ts", "../node_modules/@0b5vr/experimental/src/math/mat4/mat4LookAtInverse.ts", "../node_modules/@0b5vr/experimental/src/math/mat4/mat4Multiply.ts", "../node_modules/@0b5vr/experimental/src/math/mat4/mat4Perspective.ts", "../node_modules/@0b5vr/experimental/src/math/mat4/mat4RotationX.ts", "../node_modules/@0b5vr/experimental/src/math/mat4/mat4RotationY.ts", "../node_modules/@0b5vr/experimental/src/math/mat4/mat4RotationZ.ts", "../node_modules/@0b5vr/experimental/src/math/mat4/mat4Scale.ts", "../node_modules/@0b5vr/experimental/src/math/mat4/mat4ScaleScalar.ts", "../node_modules/@0b5vr/experimental/src/math/mat4/mat4Translate.ts", "../node_modules/@0b5vr/experimental/src/math/mat4/mat4Transpose.ts", "../node_modules/@0b5vr/experimental/src/math/mat4/Matrix4.ts", "../node_modules/@0b5vr/experimental/src/math/quat/quatFromAxisAngle.ts", "../node_modules/@0b5vr/experimental/src/math/quat/quatLookRotation.ts", "../node_modules/@0b5vr/experimental/src/math/quat/quatNormalize.ts", "../node_modules/@0b5vr/experimental/src/math/quat/quatRotationX.ts", "../node_modules/@0b5vr/experimental/src/math/quat/quatRotationY.ts", "../node_modules/@0b5vr/experimental/src/math/quat/quatRotationZ.ts", "../node_modules/@0b5vr/experimental/src/math/quat/quatSlerp.ts", "../node_modules/@0b5vr/experimental/src/math/quat/Quaternion.ts", "../node_modules/@0b5vr/experimental/src/math/mod.ts", "../node_modules/@0b5vr/experimental/src/math/sanitizeAngle.ts", "../node_modules/@0b5vr/experimental/src/math/euler/eulerFromMat3.ts", "../node_modules/@0b5vr/experimental/src/math/euler/eulerFromMat4.ts", "../node_modules/@0b5vr/experimental/src/math/euler/eulerFromQuaternion.ts", "../node_modules/@0b5vr/experimental/src/math/quat/quatFromEuler.ts", "../node_modules/@0b5vr/experimental/src/math/euler/Euler.ts", "../node_modules/@0b5vr/experimental/src/math/ray3/ray3DistanceToSphere.ts", "../node_modules/@0b5vr/experimental/src/math/line3/line3Delta.ts", "../node_modules/@0b5vr/experimental/src/math/ray3/ray3FromLine3.ts", "../node_modules/@0b5vr/experimental/src/math/ray3/Ray3.ts", "../node_modules/@0b5vr/experimental/src/math/line3/line3ApplyMatrix4.ts", "../node_modules/@0b5vr/experimental/src/math/line3/line3At.ts", "../node_modules/@0b5vr/experimental/src/math/line3/line3ClosestPointToPoint.ts", "../node_modules/@0b5vr/experimental/src/math/line3/line3DistanceToPoint.ts", "../node_modules/@0b5vr/experimental/src/math/line3/Line3.ts", "../node_modules/@0b5vr/experimental/src/math/mat2/mat2Determinant.ts", "../node_modules/@0b5vr/experimental/src/math/mat2/mat2Inverse.ts", "../node_modules/@0b5vr/experimental/src/math/mat2/mat2Multiply.ts", "../node_modules/@0b5vr/experimental/src/math/mat2/mat2Transpose.ts", "../node_modules/@0b5vr/experimental/src/math/mat2/Matrix2.ts", "../node_modules/@0b5vr/experimental/src/math/vec3/vec3ApplyMatrix3.ts", "../node_modules/@0b5vr/experimental/src/math/plane3/plane3ApplyMatrix4.ts", "../node_modules/@0b5vr/experimental/src/math/plane3/plane3DistanceToPoint.ts", "../node_modules/@0b5vr/experimental/src/math/plane3/plane3Normalize.ts", "../node_modules/@0b5vr/experimental/src/math/plane3/Plane3.ts", "../node_modules/@0b5vr/experimental/src/math/plane3/planes3ContainPoint.ts", "../node_modules/@0b5vr/experimental/src/math/plane3/planes3FromBox3.ts", "../node_modules/@0b5vr/experimental/src/math/plane3/planes3FromProjectionMatrix.ts", "../node_modules/@0b5vr/experimental/src/math/plane3/planes3IntersectBox3.ts", "../node_modules/@0b5vr/experimental/src/math/plane3/planes3IntersectSphere3.ts", "../node_modules/@0b5vr/experimental/src/math/plane3/Planes3.ts", "../node_modules/@0b5vr/experimental/src/math/sphere3/sphere3ContainsPoint.ts", "../node_modules/@0b5vr/experimental/src/math/sphere3/Sphere3.ts", "../node_modules/@0b5vr/experimental/src/math/vec4/vec4ApplyMatrix3.ts", "../node_modules/@0b5vr/experimental/src/math/vec4/Vector4.ts", "../node_modules/@0b5vr/experimental/src/midi/midiParse.ts", "../node_modules/@0b5vr/experimental/src/poker/pokerRanksByStrength.ts", "../node_modules/@0b5vr/experimental/src/poker/pokerSuitsByIndex.ts", "../node_modules/@0b5vr/experimental/src/poker/createPokerDeck.ts", "../node_modules/@0b5vr/experimental/src/poker/pokerHandStrengthMap.ts", "../node_modules/@0b5vr/experimental/src/poker/pokerRankStrengthMap.ts", "../node_modules/@0b5vr/experimental/src/poker/pokerSuitIndexMap.ts", "../node_modules/@0b5vr/experimental/src/poker/sortPokerCardsByRank.ts", "../node_modules/@0b5vr/experimental/src/poker/evaluatePokerHand.ts", "../node_modules/@0b5vr/experimental/src/poker/pokerHandsByStrength.ts", "../node_modules/@0b5vr/experimental/src/retry/asyncRetry.ts", "../node_modules/@0b5vr/experimental/src/retry/retry.ts", "../node_modules/@0b5vr/experimental/src/stniccc/parseSTNICCC.ts", "../node_modules/@0b5vr/experimental/src/stniccc/stnicccToSVG.ts", "../node_modules/@0b5vr/experimental/src/SmoothDamp/SmoothDamp.ts", "../node_modules/@0b5vr/experimental/src/Swap/Swap.ts", "../node_modules/@0b5vr/experimental/src/TapTempo/TapTempo.ts", "../node_modules/@0b5vr/experimental/src/tinyseq/createTinyseqPolyReader.ts", "../node_modules/@0b5vr/experimental/src/tinyseq/createTinyseqReader.ts", "../node_modules/@0b5vr/experimental/src/tinyseq/tinyseqFromMidiParseResult.ts", "../node_modules/@0b5vr/experimental/src/Xorshift/Xorshift.ts", "../node_modules/@0b5vr/experimental/src/yugop/getYugopText.ts", "../node_modules/@0b5vr/experimental/src/BinaryHeap.ts", "../node_modules/@0b5vr/experimental/src/notifyObservers.ts", "../src/shaderchunks.ts", "../src/utils/glWaitGPUCommandsCompleteAsync.ts", "../src/utils/lazyProgram.ts", "../src/Renderer.ts", "../src/utils/EventEmittable.ts", "../src/utils/applyMixins.ts", "../src/utils/mod.ts", "../src/BeatManager.ts", "../src/BufferReaderNode.ts", "../src/TextureStore.ts", "../src/utils/lerp.ts", "../src/WavenerdDeck.ts"],
  "sourcesContent": ["export { WavenerdDeck } from './WavenerdDeck';\nexport { BeatManager } from './BeatManager';\n\nimport { WavenerdDeck } from './WavenerdDeck';\nexport default WavenerdDeck;\n", "// yoinked from https://stackoverflow.com/questions/1344500/efficient-way-to-insert-a-number-into-a-sorted-array-of-numbers\n\n/**\n * Look for an index from a sorted list using binary search.\n *\n * If you don't provide a compare function, it will look for **the first same value** it can find.\n * If it cannot find an exactly matching value, it can return N where the length of given array is N.\n *\n * @param array A sorted array\n * @param compare Make this function return `false` if you want to point right side of given element, `true` if you want to point left side of given element.\n * @returns An index found\n */\nexport function binarySearch<T>( array: ArrayLike<T>, element: T ): number;\nexport function binarySearch<T>( array: ArrayLike<T>, compare: ( element: T ) => boolean ): number;\nexport function binarySearch<T>(\n  array: ArrayLike<T>,\n  elementOrCompare: T | ( ( element: T ) => boolean ),\n): number {\n  if ( typeof elementOrCompare !== 'function' ) {\n    return binarySearch( array, ( element ) => ( element < elementOrCompare ) );\n  }\n  const compare = elementOrCompare as ( element: T ) => boolean;\n\n  let start = 0;\n  let end = array.length;\n\n  while ( start < end ) {\n    const center = ( start + end ) >> 1;\n    const centerElement = array[ center ];\n\n    const compareResult = compare( centerElement );\n\n    if ( compareResult ) {\n      start = center + 1;\n    } else {\n      end = center;\n    }\n  }\n\n  return start;\n}\n", "/**\n * Generic traverse function.\n *\n * It performs Depth-First Search.\n *\n * The `traverser` function will be executed for each descendants.\n * You need to return their \"children\" in an array.\n * If you want to stop the traversal, return `false` instead.\n *\n * @example\n * ```js\n * // replicate Three.js traverse for no reason\n * const meshes = [];\n * traverse( object3DRoot, ( object ) => {\n *   if ( object.isMesh ) {\n *     meshes.push( object );\n *   }\n *   return object3DRoot.children;\n * } );\n * ```\n *\n * @param root The \"root\" node\n * @param traverser The traverse function. If the node has \"children\" return them in an array.\n */\nexport function traverse<TNode>(\n  root: TNode,\n  traverser: ( node: TNode ) => TNode[] | false,\n): void {\n  const nodesNeedProcess: TNode[] = [ root ];\n  const nodesSeen = new Set<TNode>( nodesNeedProcess );\n\n  while ( nodesNeedProcess.length > 0 ) {\n    const currentNode = nodesNeedProcess.shift()!;\n\n    const children = traverser( currentNode );\n\n    if ( !children ) {\n      break;\n    }\n\n    const nodesFound = children.filter( ( node ) => !nodesSeen.has( node ) );\n    nodesNeedProcess.unshift( ...nodesFound );\n    nodesFound.map( ( node ) => nodesSeen.add( node ) );\n  }\n}\n", "export function arrayRange( start: number, end: number, step?: number ): number[] {\n  let current = start;\n  const ret: number[] = [];\n\n  if ( start < end ) {\n    step = step ?? 1;\n    while ( current < end ) {\n      ret.push( current );\n      current += step;\n    }\n  } else {\n    step = step ?? -1;\n    while ( current > end ) {\n      ret.push( current );\n      current += step;\n    }\n  }\n\n  return ret;\n}\n\n", "export const arraySerial = ( count: number ): number[] => (\n  [ ...Array( count ) ].map( ( _, i ) => i )\n);\n", "export function arraySetDelete<T>( array: Array<T>, value: T ): boolean {\n  const index = array.indexOf( value );\n  if ( index === -1 ) { return false; }\n\n  array.splice( index, 1 );\n  return true;\n}\n\nexport function arraySetHas<T>( array: Array<T>, value: T ): boolean {\n  return array.indexOf( value ) !== -1;\n}\n\nexport function arraySetAdd<T>( array: Array<T>, value: T ): boolean {\n  const index = array.indexOf( value );\n  if ( index !== -1 ) { return false; }\n\n  array.push( value );\n  return true;\n}\n\nexport function arraySetUnion<T>( a: Array<T>, b: Array<T> ): Array<T> {\n  const out = [ ...a ];\n  b.forEach( ( v ) => {\n    if ( !arraySetHas( out, v ) ) {\n      out.push( v );\n    }\n  } );\n  return out;\n}\n\nexport function arraySetDiff<T>( from: Array<T>, diff: Array<T> ): Array<T> {\n  const out = [ ...from ];\n  diff.forEach( ( v ) => {\n    arraySetDelete( out, v );\n  } );\n  return out;\n}\n", "/**\n * `[ -1, -1, 1, -1, -1, 1, 1, 1 ]`\n */\nexport const TRIANGLE_STRIP_QUAD = [ -1, -1, 1, -1, -1, 1, 1, 1 ];\n\n/**\n * `[ -1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0 ]`\n */\nexport const TRIANGLE_STRIP_QUAD_3D = [ -1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0 ];\n\n/**\n * `[ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1 ]`\n */\nexport const TRIANGLE_STRIP_QUAD_NORMAL = [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1 ];\n\n/**\n * `[ 0, 0, 1, 0, 0, 1, 1, 1 ]`\n */\nexport const TRIANGLE_STRIP_QUAD_UV = [ 0, 0, 1, 0, 0, 1, 1, 1 ];\n", "/**\n * Shuffle given `array` using given `dice` RNG. **Destructive**.\n */\nexport function shuffleArray<T>( array: T[], dice?: () => number ): T[] {\n  const f = dice ? dice : () => Math.random();\n  for ( let i = 0; i < array.length - 1; i ++ ) {\n    const ir = i + Math.floor( f() * ( array.length - i ) );\n    const temp = array[ ir ];\n    array[ ir ] = array[ i ];\n    array[ i ] = temp;\n  }\n  return array;\n}\n\n/**\n * I like wireframe\n *\n * `triIndexToLineIndex( [ 0, 1, 2, 5, 6, 7 ] )` -> `[ 0, 1, 1, 2, 2, 0, 5, 6, 6, 7, 7, 5 ]`\n */\nexport function triIndexToLineIndex<T>( array: T[] ): T[] {\n  const ret: T[] = [];\n  for ( let i = 0; i < array.length / 3; i ++ ) {\n    const head = i * 3;\n    ret.push(\n      array[ head     ], array[ head + 1 ],\n      array[ head + 1 ], array[ head + 2 ],\n      array[ head + 2 ], array[ head     ]\n    );\n  }\n  return ret;\n}\n\n/**\n * `matrix2d( 3, 2 )` -> `[ 0, 0, 0, 1, 0, 2, 1, 0, 1, 1, 1, 2 ]`\n */\nexport function matrix2d( w: number, h: number ): number[] {\n  const arr: number[] = [];\n  for ( let iy = 0; iy < h; iy ++ ) {\n    for ( let ix = 0; ix < w; ix ++ ) {\n      arr.push( ix, iy );\n    }\n  }\n  return arr;\n}\n\n/**\n * See also: {@link matrix2d}\n */\nexport function matrix3d( w: number, h: number, d: number ): number[] {\n  const arr: number[] = [];\n  for ( let iz = 0; iz < d; iz ++ ) {\n    for ( let iy = 0; iy < h; iy ++ ) {\n      for ( let ix = 0; ix < w; ix ++ ) {\n        arr.push( ix, iy, iz );\n      }\n    }\n  }\n  return arr;\n}\n", "/**\n * Critically Damped Spring\n *\n * Shoutouts to Keijiro Takahashi\n */\nexport class CDS {\n  public factor = 100.0;\n  public ratio = 1.0;\n  public velocity = 0.0;\n  public value = 0.0;\n  public target = 0.0;\n\n  public update( deltaTime: number ): number {\n    this.velocity += (\n      -this.factor * ( this.value - this.target )\n      - 2.0 * this.velocity * Math.sqrt( this.factor ) * this.ratio\n    ) * deltaTime;\n    this.value += this.velocity * deltaTime;\n    return this.value;\n  }\n}\n", "/**\n * Class that deals with time.\n * In this base class, you need to set time manually from `Automaton.update()`.\n * Best for sync with external clock stuff.\n */\nexport class Clock {\n  /**\n   * Its current time.\n   */\n  protected __time = 0.0;\n\n  /**\n   * Its deltaTime of last update.\n   */\n  protected __deltaTime = 0.0;\n\n  /**\n   * Whether its currently playing or not.\n   */\n  protected __isPlaying = false;\n\n  /**\n   * Its current time.\n   */\n  public get time(): number { return this.__time; }\n\n  /**\n   * Its deltaTime of last update.\n   */\n  public get deltaTime(): number { return this.__deltaTime; }\n\n  /**\n   * Whether its currently playing or not.\n   */\n  public get isPlaying(): boolean { return this.__isPlaying; }\n\n  /**\n   * Update the clock.\n   * @param time Time. You need to set manually when you are using manual Clock\n   */\n  public update( time?: number ): void {\n    const prevTime = this.__time;\n    this.__time = time || 0.0;\n    this.__deltaTime = this.__time - prevTime;\n  }\n\n  /**\n   * Start the clock.\n   */\n  public play(): void {\n    this.__isPlaying = true;\n  }\n\n  /**\n   * Stop the clock.\n   */\n  public pause(): void {\n    this.__isPlaying = false;\n  }\n\n  /**\n   * Set the time manually.\n   * @param time Time\n   */\n  public setTime( time: number ): void {\n    this.__time = time;\n  }\n}\n", "import { Clock } from './Clock';\n\n/**\n * Class that deals with time.\n * This is \"frame\" type clock, the frame increases every {@link ClockFrame#update} call.\n * @param fps Frames per second\n */\nexport class ClockFrame extends Clock {\n  /**\n   * Its current frame.\n   */\n  private __frame = 0;\n\n  /**\n   * Its fps.\n   */\n  private __fps: number;\n\n  public constructor( fps = 60 ) {\n    super();\n    this.__fps = fps;\n  }\n\n  /**\n   * Its current frame.\n   */\n  public get frame(): number { return this.__frame; }\n\n  /**\n   * Its fps.\n   */\n  public get fps(): number { return this.__fps; }\n\n  /**\n   * Update the clock. It will increase the frame by 1.\n   */\n  public update(): void {\n    if ( this.__isPlaying ) {\n      this.__time = this.__frame / this.__fps;\n      this.__deltaTime = 1.0 / this.__fps;\n      this.__frame ++;\n    } else {\n      this.__deltaTime = 0.0;\n    }\n  }\n\n  /**\n   * Set the time manually.\n   * The set time will be converted into internal frame count, so the time will not be exactly same as set one.\n   * @param time Time\n   */\n  public setTime( time: number ): void {\n    this.__frame = Math.floor( this.__fps * time );\n    this.__time = this.__frame / this.__fps;\n  }\n}\n", "import { Clock } from './Clock';\n\n/**\n * Class that deals with time.\n * This is \"realtime\" type clock, the time goes on as real world.\n */\nexport class ClockRealtime extends Clock {\n  /**\n   * \"You set the time manually to `__rtTime` when it's `__rtDate`.\"\n   */\n  private __rtTime = 0.0;\n\n  /**\n   * \"You set the time manually to `__rtTime` when it's `__rtDate`.\"\n   */\n  private __rtDate: number = performance.now();\n\n  /**\n   * The clock is realtime. yeah.\n   */\n  public get isRealtime(): boolean { return true; }\n\n  /**\n   * Update the clock. Time is calculated based on time in real world.\n   */\n  public update(): void {\n    const now = performance.now();\n\n    if ( this.__isPlaying ) {\n      const prevTime = this.__time;\n      const deltaDate = ( now - this.__rtDate );\n      this.__time = this.__rtTime + deltaDate / 1000.0;\n      this.__deltaTime = this.time - prevTime;\n    } else {\n      this.__rtTime = this.time;\n      this.__rtDate = now;\n      this.__deltaTime = 0.0;\n    }\n  }\n\n  /**\n   * Set the time manually.\n   * @param time Time\n   */\n  public setTime( time: number ): void {\n    this.__time = time;\n    this.__rtTime = this.time;\n    this.__rtDate = performance.now();\n  }\n}\n", "import type { RawRGB } from './RawRGB';\n\n/**\n * Converts the input color in Atari-ST color palette format to a {@link RawRGB}.\n *\n * @param stColor A color in Atari-ST format\n */\nexport function colorFromAtariST( stColor: number ): RawRGB {\n  return [\n    ( stColor >> 8 & 7 ) / 7.0,\n    ( stColor >> 4 & 7 ) / 7.0,\n    ( stColor & 7 ) / 7.0,\n  ];\n}\n", "/**\n * `lerp`, or `mix`\n */\nexport function lerp( a: number, b: number, x: number ): number {\n  return a + ( b - a ) * x;\n}\n\n/**\n * `clamp`\n */\nexport function clamp( x: number, l: number, h: number ): number {\n  return Math.min( Math.max( x, l ), h );\n}\n\n/**\n * `clamp( x, 0.0, 1.0 )`\n */\nexport function saturate( x: number ): number {\n  return clamp( x, 0.0, 1.0 );\n}\n\n/**\n * Transform a value from input range to output range.\n */\nexport function range( x: number, x0: number, x1: number, y0: number, y1: number ): number {\n  return ( ( x - x0 ) * ( y1 - y0 ) / ( x1 - x0 ) + y0 );\n}\n\n/**\n * `smoothstep` but not smooth\n */\nexport function linearstep( a: number, b: number, x: number ): number {\n  return saturate( ( x - a ) / ( b - a ) );\n}\n\n/**\n * world famous `smoothstep` function\n */\nexport function smoothstep( a: number, b: number, x: number ): number {\n  const t = linearstep( a, b, x );\n  return t * t * ( 3.0 - 2.0 * t );\n}\n\n/**\n * `smoothstep` but more smooth\n */\nexport function smootherstep( a: number, b: number, x: number ): number {\n  const t = linearstep( a, b, x );\n  return t * t * t * ( t * ( t * 6.0 - 15.0 ) + 10.0 );\n}\n\n/**\n * `smoothstep` but WAY more smooth\n */\nexport function smootheststep( a: number, b: number, x: number ): number {\n  const t = linearstep( a, b, x );\n  return t * t * t * t * ( t * ( t * ( -20.0 * t + 70.0 ) - 84.0 ) + 35.0 );\n}\n", "import { RawRGB } from './RawRGB';\nimport { lerp } from '../math/utils';\n\n/**\n * Convert a color from HSV to RGB.\n * Each component of the HSV must be given in [0 - 1] range.\n *\n * Ref: https://en.wikipedia.org/wiki/HSV_color_space\n */\nexport function colorHSV2RGB( [ h, s, v ]: [ number, number, number ] ): RawRGB {\n  const ht = h % 1.0 * 6.0;\n\n  return [ 0.0, 4.0, 2.0 ].map( ( p ) => {\n    const colH = Math.min( Math.max( (\n      Math.abs( ( ht + p ) % 6.0 - 3.0 ) - 1.0\n    ), 0.0 ), 1.0 );\n    const colS = lerp( 1.0, colH, s );\n    return v * colS;\n  } ) as RawRGB;\n}\n", "import { saturate } from '../math/utils';\nimport type { RawRGB } from './RawRGB';\n\n/**\n * Converts the input color to hex representation (e.g. #7f7f7f)\n * @param color color in {@link RawRGB}\n */\nexport function colorToHex( color: RawRGB ): string {\n  return '#' + color.map( ( v ) => (\n    ( '0' + ( Math.round( saturate( v ) * 255.0 ) ).toString( 16 ) ).slice( -2 )\n  ) ).join( '' );\n}\n", "/**\n * Return a dot product of given two vectors.\n */\nexport function vecDot<T extends number[]>( vecA: T, vecB: T ): number {\n  return vecA.reduce( ( sum, v, i ) => sum + v * vecB[ i ], 0.0 );\n}\n", "/*!\n * Turbo colormap\n *\n * Copyright 2019 Google LLC. (Apache-2.0)\n *\n * https://gist.github.com/mikhailov-work/0d177465a8151eb6ede1768d51d476c7\n */\n\nimport { RawRGB } from './RawRGB';\nimport { saturate } from '../math/utils';\nimport { vecDot } from '../math/vec/vecDot';\n\n/**\n * Generate a turbo gradient.\n *\n * Ref: https://gist.github.com/mikhailov-work/0d177465a8151eb6ede1768d51d476c7\n */\nexport function colorTurbo( x: number ): RawRGB {\n  const kr = [\n    0.13572138, 4.61539260, -42.66032258,\n    132.13108234, -152.94239396, 59.28637943,\n  ];\n  const kg = [\n    0.09140261, 2.19418839, 4.84296658,\n    -14.18503333, 4.27729857, 2.82956604,\n  ];\n  const kb = [\n    0.10667330, 12.64194608, -60.58204836,\n    110.36276771, -89.90310912, 27.34824973,\n  ];\n\n  const xt = saturate( x );\n  const xv = [\n    1.0,\n    xt,\n    xt * xt,\n    xt * xt * xt,\n    xt * xt * xt * xt,\n    xt * xt * xt * xt * xt,\n  ];\n\n  const col = [\n    saturate( vecDot( kr, xv ) ),\n    saturate( vecDot( kg, xv ) ),\n    saturate( vecDot( kb, xv ) ),\n  ];\n\n  return col as RawRGB;\n}\n", "import type { RawRGB } from './RawRGB';\n\n/**\n * EOTF of Rec.709 a.k.a. sRGB-to-Linear\n */\nexport function eotfRec709( value: RawRGB ): RawRGB {\n  return value.map( ( v ) => (\n    v < 0.081\n      ? v / 4.5\n      : Math.pow( ( v + 0.099 ) / 1.099, 1.0 / 0.45 )\n  ) ) as RawRGB;\n}\n", "import type { RawRGB } from './RawRGB';\n\n/**\n * OETF of Rec.709 a.k.a. Linear-to-sRGB\n */\nexport function oetfRec709( luminance: RawRGB ): RawRGB {\n  return luminance.map( ( l ) => (\n    l < 0.018\n      ? 4.5 * l\n      : 1.099 * Math.pow( l, 0.45 ) - 0.099\n  ) ) as RawRGB;\n}\n", "import { RawDagEdge } from './RawDagEdge';\n\n/**\n * Return all parent sources the specified destination has.\n * @param edges An array of dag edge\n * @param destination The target destination\n *\n * See also: {@link dagEdgesChildren}\n */\nexport function dagEdgesParents<T>( edges: RawDagEdge<T>[], destination: T ): T[] {\n  return edges\n    .filter( ( edge ) => edge[ 1 ] === destination )\n    .map( ( edge ) => edge[ 0 ] );\n}\n", "import { dagEdgesParents } from './dagEdgesParents';\nimport { traverse } from '../algorithm/traverse';\nimport type { RawDagEdge } from './RawDagEdge';\n\n/**\n * Return all ancestor sources the specified destination has.\n * @param edges An array of dag edge\n * @param destination The target destination\n *\n * See also: {@link dagEdgesChildren}\n */\nexport function dagEdgesAncestors<T>( edges: RawDagEdge<T>[], destination: T ): T[] {\n  const ancestors = new Set<T>();\n\n  traverse( destination, ( node ) => {\n    const parents = dagEdgesParents( edges, node );\n    parents.map( ( parent ) => ancestors.add( parent ) );\n    return parents;\n  } );\n\n  return Array.from( ancestors );\n}\n", "import { RawDagEdge } from './RawDagEdge';\n\n/**\n * Return all children destinations the specified source has.\n * @param edges An array of dag edge\n * @param source The target source\n *\n * See also: {@link dagEdgesDescendant}\n */\nexport function dagEdgesChildren<T>( edges: RawDagEdge<T>[], source: T ): T[] {\n  return edges\n    .filter( ( edge ) => edge[ 0 ] === source )\n    .map( ( edge ) => edge[ 1 ] );\n}\n", "import { dagEdgesChildren } from './dagEdgesChildren';\nimport { traverse } from '../algorithm/traverse';\nimport type { RawDagEdge } from './RawDagEdge';\n\n/**\n * Return all descendant destinations the specified source has.\n * @param edges An array of dag edge\n * @param source The target source\n *\n * See also: {@link dagEdgesChildren}\n */\nexport function dagEdgesDescendants<T>( edges: RawDagEdge<T>[], source: T ): T[] {\n  const descendants = new Set<T>();\n\n  traverse( source, ( node ) => {\n    const children = dagEdgesChildren( edges, node );\n    children.map( ( child ) => descendants.add( child ) );\n    return children;\n  } );\n\n  return Array.from( descendants );\n}\n", "import { RawDagEdge } from './RawDagEdge';\n\n/**\n * Return first parent source the specified destination has.\n * If it can't find a parent, it will return `null` instead.\n *\n * @param edges An array of dag edge\n * @param destination The target destination\n *\n * See also: {@link dagEdgesParents}\n */\nexport function dagEdgesParent<T>( edges: RawDagEdge<T>[], destination: T ): T | null {\n  return edges.find( ( edge ) => edge[ 1 ] === destination )?.[ 0 ] ?? null;\n}\n", "import { RawDagEdge } from './RawDagEdge';\nimport { dagEdgesParent } from './dagEdgesParent';\n\n/**\n * Resolve dag dependency relationship and give you a correct order.\n *\n * @param edges An array of dag edges\n * @param nodes An array of dag nodes\n */\nexport function dagEdgesResolve<T>( edges: RawDagEdge<T>[], nodes: T[] ): T[] {\n  const order: T[] = [];\n\n  const nodeSet = new Set( nodes );\n  let tempEdges = edges.concat();\n\n  while ( tempEdges.length > 0 ) {\n    nodeSet.forEach( ( node ) => {\n      // is this an entrypoint?\n      const hasParents = dagEdgesParent( tempEdges, node ) != null;\n\n      if ( !hasParents ) {\n        nodeSet.delete( node );\n        order.push( node );\n\n        // delete the structure of tempEdges from entrypoint side\n        tempEdges = tempEdges.filter( ( [ src ] ) => ( src !== node ) );\n      }\n    } );\n  }\n\n  return order.concat( Array.from( nodeSet ) );\n  //                   ^^^^^^^^^^^^^^^^^^^^^ terminator nodes\n}\n", "// yoinked from https://github.com/mapbox/tiny-sdf (BSD 2-Clause)\n// implements http://people.cs.uchicago.edu/~pff/papers/dt.pdf\n\n/**\n * Compute a one dimensional edt from the source data.\n * Returning distance will be squared.\n * Intended to be used internally in {@link edt2d}.\n *\n * @param data Data of the source\n * @param offset Offset of the source from beginning\n * @param stride Stride of the source\n * @param length Length of the source\n */\nexport function edt1d(\n  data: Float32Array,\n  offset: number,\n  stride: number,\n  length: number\n): void {\n  // index of rightmost parabola in lower envelope\n  let k = 0;\n\n  // locations of parabolas in lower envelope\n  const v = new Float32Array( length );\n  v[ 0 ] = 0.0;\n\n  // locations of boundaries between parabolas\n  const z = new Float32Array( length + 1 );\n  z[ 0 ] = -Infinity;\n  z[ 1 ] = Infinity;\n\n  // create a straight array of input data\n  const f = new Float32Array( length );\n  for ( let q = 0; q < length; q ++ ) {\n    f[ q ] = data[ offset + q * stride ];\n  }\n\n  // compute lower envelope\n  for ( let q = 1; q < length; q ++ ) {\n    let s = 0.0;\n\n    while ( 0 <= k ) {\n      s = ( f[ q ] + q * q - f[ v[ k ] ] - v[ k ] * v[ k ] ) / ( 2.0 * q - 2.0 * v[ k ] );\n      if ( s <= z[ k ] ) {\n        k --;\n      } else {\n        break;\n      }\n    }\n\n    k ++;\n    v[ k ] = q;\n    z[ k ] = s;\n    z[ k + 1 ] = Infinity;\n  }\n\n  k = 0;\n\n  // fill in values of distance transform\n  for ( let q = 0; q < length; q ++ ) {\n    while ( z[ k + 1 ] < q ) { k ++; }\n    const qSubVK = q - v[ k ];\n    data[ offset + q * stride ] = f[ v[ k ] ] + qSubVK * qSubVK;\n  }\n}\n\n/**\n * Compute a two dimensional edt from the source data.\n * Returning distance will be squared.\n *\n * @param data Data of the source.\n * @param width Width of the source.\n * @param height Height of the source.\n */\nexport function edt2d(\n  data: Float32Array,\n  width: number,\n  height: number\n): void {\n  for ( let x = 0; x < width; x ++ ) {\n    edt1d( data, x, width, height );\n  }\n\n  for ( let y = 0; y < height; y ++ ) {\n    edt1d( data, y * width, 1, width );\n  }\n}\n", "import { lerp } from '../math/utils';\n\n/**\n * Do exp smoothing\n */\nexport class ExpSmooth {\n  public factor = 10.0;\n  public target = 0.0;\n  public value = 0.0;\n\n  public update( deltaTime: number ): number {\n    this.value = lerp( this.target, this.value, Math.exp( -this.factor * deltaTime ) );\n    return this.value;\n  }\n}\n", "export class Pool<T> {\n  public array: T[];\n\n  public index = 0;\n\n  public get current(): T {\n    return this.array[ this.index ];\n  }\n\n  public constructor( array: T[] ) {\n    this.array = array;\n  }\n\n  public next(): T {\n    this.index = ( this.index + 1 ) % this.array.length;\n    return this.current;\n  }\n}\n", "import { Pool } from '../Pool/Pool';\n\nexport class GPUTimer {\n  public queries: Pool<WebGLQuery>;\n  public stack: Promise<number>[];\n  public ext: any;\n  public readonly gl: WebGL2RenderingContext;\n\n  private __loopTasks: Set<() => void>;\n\n  public static isSupported( gl: WebGLRenderingContext | WebGL2RenderingContext ): boolean {\n    return new Set( gl.getSupportedExtensions() ).has( 'EXT_disjoint_timer_query_webgl2' );\n  }\n\n  public constructor( gl: WebGL2RenderingContext ) {\n    this.gl = gl;\n\n    const queries = new Array( 1024 ).fill( 1 ).map( () => gl.createQuery()! );\n    this.queries = new Pool( queries );\n\n    this.stack = [];\n\n    this.ext = gl.getExtension( 'EXT_disjoint_timer_query_webgl2' );\n\n    this.__loopTasks = new Set();\n\n    // loop\n    const update = (): void => {\n      this.update();\n      requestAnimationFrame( update );\n    };\n    update();\n  }\n\n  public update(): void {\n    Array.from( this.__loopTasks ).forEach( ( task ) => task() );\n  }\n\n  public async measure( func: () => void ): Promise<number> {\n    const { gl } = this;\n\n    if ( this.stack.length !== 0 ) {\n      gl.endQuery( this.ext.TIME_ELAPSED_EXT );\n      const promiseFinishingPrev = this.check( this.queries.current );\n\n      this.stack = this.stack.map( async ( promiseAccum ) => {\n        return ( await promiseAccum ) + ( await promiseFinishingPrev );\n      } );\n    }\n\n    this.stack.push( Promise.resolve( 0.0 ) );\n\n    gl.beginQuery( this.ext.TIME_ELAPSED_EXT, this.queries.next() );\n\n    func();\n\n    gl.endQuery( this.ext.TIME_ELAPSED_EXT );\n\n    const promiseAccum = this.stack.pop()!;\n    const promiseThis = this.check( this.queries.current );\n\n    if ( this.stack.length !== 0 ) {\n      this.stack = this.stack.map( async ( promiseAccum ) => {\n        return ( await promiseAccum ) + ( await promiseThis );\n      } );\n\n      gl.beginQuery( this.ext.TIME_ELAPSED_EXT, this.queries.next() );\n    }\n\n    return ( await promiseAccum ) + ( await promiseThis );\n  }\n\n  public check( query: WebGLQuery ): Promise<number> {\n    const { gl } = this;\n\n    return new Promise( ( resolve ) => {\n      const task = (): void => {\n        const isAvailable = gl.getQueryParameter( query, gl.QUERY_RESULT_AVAILABLE );\n\n        if ( isAvailable ) {\n          this.__loopTasks.delete( task );\n          resolve( gl.getQueryParameter( query, gl.QUERY_RESULT ) * 0.001 * 0.001 );\n        }\n      };\n\n      this.__loopTasks.add( task );\n    } );\n  }\n}\n", "/**\n * Useful for tap tempo\n * See also: {@link HistoryMeanCalculator}\n */\nexport class HistoryMeanCalculator {\n  private __recalcForEach = 0;\n  private __countUntilRecalc = 0;\n  private __history: number[] = [];\n  private __index = 0;\n  private __length: number;\n  private __count = 0;\n  private __cache = 0;\n\n  public constructor( length: number ) {\n    this.__length = length;\n    this.__recalcForEach = length;\n    for ( let i = 0; i < length; i ++ ) {\n      this.__history[ i ] = 0;\n    }\n  }\n\n  public get mean(): number {\n    const count = Math.min( this.__count, this.__length );\n    return count === 0 ? 0.0 : this.__cache / count;\n  }\n\n  public get recalcForEach(): number {\n    return this.__recalcForEach;\n  }\n\n  public set recalcForEach( value: number ) {\n    const delta = value - this.__recalcForEach;\n    this.__recalcForEach = value;\n    this.__countUntilRecalc = Math.max( 0, this.__countUntilRecalc + delta );\n  }\n\n  public reset(): void {\n    this.__index = 0;\n    this.__count = 0;\n    this.__cache = 0;\n    this.__countUntilRecalc = 0;\n    for ( let i = 0; i < this.__length; i ++ ) {\n      this.__history[ i ] = 0;\n    }\n  }\n\n  public push( value: number ): void {\n    const prev = this.__history[ this.__index ];\n    this.__history[ this.__index ] = value;\n    this.__count ++;\n    this.__index = ( this.__index + 1 ) % this.__length;\n\n    if ( this.__countUntilRecalc === 0 ) {\n      this.recalc();\n    } else {\n      this.__countUntilRecalc --;\n      this.__cache -= prev;\n      this.__cache += value;\n    }\n  }\n\n  public recalc(): void {\n    this.__countUntilRecalc = this.__recalcForEach;\n    const sum = this.__history\n      .slice( 0, Math.min( this.__count, this.__length ) )\n      .reduce( ( sum, v ) => sum + v, 0 );\n    this.__cache = sum;\n  }\n}\n", "import { binarySearch } from '../algorithm/binarySearch';\n\n/**\n * Useful for fps calc\n * See also: {@link HistoryMeanCalculator}\n */\nexport class HistoryPercentileCalculator {\n  private __history: number[] = [];\n  private __sorted: number[] = [];\n  private __index = 0;\n  private readonly __length: number;\n\n  public constructor( length: number ) {\n    this.__length = length;\n  }\n\n  public get median(): number {\n    return this.percentile( 50.0 );\n  }\n\n  public percentile( percentile: number ): number {\n    if ( this.__history.length === 0 ) { return 0.0; }\n    return this.__sorted[ Math.round( percentile * 0.01 * ( this.__history.length - 1 ) ) ];\n  }\n\n  public reset(): void {\n    this.__index = 0;\n    this.__history = [];\n    this.__sorted = [];\n  }\n\n  public push( value: number ): void {\n    const prev = this.__history[ this.__index ];\n    this.__history[ this.__index ] = value;\n    this.__index = ( this.__index + 1 ) % this.__length;\n\n    // remove the prev from sorted array\n    if ( this.__sorted.length === this.__length ) {\n      const prevIndex = binarySearch( this.__sorted, prev );\n      this.__sorted.splice( prevIndex, 1 );\n    }\n\n    const index = binarySearch( this.__sorted, value );\n    this.__sorted.splice( index, 0, value );\n  }\n}\n", "import { HistoryPercentileCalculator } from './HistoryPercentileCalculator';\n\n/**\n * @deprecated It's actually just a special case of {@link HistoryPercentileCalculator}\n */\nexport class HistoryMedianCalculator extends HistoryPercentileCalculator {\n  public constructor( length: number ) {\n    super( length );\n    console.warn( 'HistoryMedianCalculator: Deprecated. Use HistoryPercentileCalculator instead' );\n  }\n}\n", "export class MapOfSet<K, V> {\n  public readonly map: Map<K, Set<V>>;\n\n  public constructor() {\n    this.map = new Map();\n  }\n\n  public get( key: K ): Set<V> {\n    return this.map.get( key ) ?? new Set();\n  }\n\n  public add( key: K, value: V ): void {\n    let set = this.map.get( key );\n    if ( set == null ) {\n      set = new Set();\n      this.map.set( key, set );\n    }\n    set.add( value );\n  }\n}\n", "/**\n * Return a vector with the absolute of each component of the given vector.\n */\nexport function vecAbs<T extends number[]>( vec: T ): T {\n  return vec.map( ( v ) => Math.abs( v ) ) as T;\n}\n", "/**\n * Return a sum of vectors.\n */\nexport function vecAdd<T extends number[]>( ...vecs: T[] ): T {\n  if ( vecs.length < 2 ) {\n    return vecs[ 0 ];\n  }\n\n  const a = vecs.shift()!;\n  const b = vecAdd( ...vecs );\n\n  return a.map( ( v, i ) => v + b[ i ] ) as T;\n}\n", "/**\n * Divide a vector by a vector.\n */\nexport function vecDivide<T extends number[]>( vecA: T, vecB: T ): T {\n  return vecA.map( ( v, i ) => v / vecB[ i ] ) as T;\n}\n", "/**\n * Return an euclidean length of given vector.\n */\nexport function vecLength<T extends number[]>( vec: T ): number {\n  return Math.sqrt( vec.reduce( ( sum, v ) => sum + v * v, 0.0 ) );\n}\n", "/**\n * Return an squared euclidean length of given vector.\n */\nexport function vecLengthSq<T extends number[]>( vec: T ): number {\n  return vec.reduce( ( sum, v ) => sum + v * v, 0.0 );\n}\n", "/**\n * Return a manhattan length of given vector.\n */\nexport function vecManhattanLength<T extends number[]>( vec: T ): number {\n  return vec.reduce( ( sum, v ) => sum + Math.abs( v ), 0.0 );\n}\n", "/**\n * Return a product of vectors.\n */\nexport function vecMultiply<T extends number[]>( ...vecs: T[] ): T {\n  if ( vecs.length < 2 ) {\n    return vecs[ 0 ];\n  }\n\n  const a = vecs.shift()!;\n  const b = vecMultiply( ...vecs );\n\n  return a.map( ( v, i ) => v * b[ i ] ) as T;\n}\n", "/**\n * Negate a vector.\n */\nexport function vecNeg<T extends number[]>( vec: T ): T {\n  return vec.map( ( v ) => -v ) as T;\n}\n", "/**\n * Scale the given vector by a scalar.\n */\nexport function vecScale<T extends number[]>( vec: T, scalar: number ): T {\n  return vec.map( ( v ) => v * scalar ) as T;\n}\n", "import { vecLength } from './vecLength';\nimport { vecScale } from './vecScale';\n\n/**\n * Normalize given vector.\n * If the length of given vector is 0.0, it will return a zero vector instead.\n */\nexport function vecNormalize<T extends number[]>( vec: T ): T {\n  const len = vecLength( vec );\n  const invLen = len === 0.0 ? 0.0 : 1.0 / len;\n  return vecScale( vec, invLen );\n}\n", "/**\n * Subtract a vector from a vector.\n */\nexport function vecSub<T extends number[]>( vecA: T, vecB: T ): T {\n  return vecA.map( ( v, i ) => v - vecB[ i ] ) as T;\n}\n", "import { vecAbs } from './vecAbs';\nimport { vecAdd } from './vecAdd';\nimport { vecDivide } from './vecDivide';\nimport { vecDot } from './vecDot';\nimport { vecLength } from './vecLength';\nimport { vecLengthSq } from './vecLengthSq';\nimport { vecManhattanLength } from './vecManhattanLength';\nimport { vecMultiply } from './vecMultiply';\nimport { vecNeg } from './vecNeg';\nimport { vecNormalize } from './vecNormalize';\nimport { vecScale } from './vecScale';\nimport { vecSub } from './vecSub';\n\n/**\n * A Vector.\n */\nexport abstract class Vector<T extends Vector<T>> {\n  public abstract elements: number[];\n\n  /**\n   * The length of this.\n   * a.k.a. `magnitude`\n   */\n  public get length(): number {\n    return vecLength( this.elements );\n  }\n\n  /**\n   * The squared length of this.\n   */\n  public get lengthSq(): number {\n    return vecLengthSq( this.elements );\n  }\n\n  /**\n   * The manhattan length of this.\n   */\n  public get manhattanLength(): number {\n    return vecManhattanLength( this.elements );\n  }\n\n  /**\n   * A normalized Vector3 of this.\n   */\n  public get normalized(): T {\n    return this.__new( vecNormalize( this.elements ) );\n  }\n\n  /**\n   * This but negated.\n   */\n  public get negated(): T {\n    return this.__new( vecNeg( this.elements ) );\n  }\n\n  /**\n   * This but each component is the absolute.\n   */\n  public get abs(): T {\n    return this.__new( vecAbs( this.elements ) );\n  }\n\n  /**\n   * Clone this.\n   */\n  public clone(): T {\n    return this.__new( this.elements.concat() );\n  }\n\n  /**\n   * Add one or more Vector into this.\n   * @param vectors Other Vectors\n   */\n  public add( ...vectors: T[] ): T {\n    return this.__new( vecAdd( this.elements, ...vectors.map( ( v ) => v.elements ) ) );\n  }\n\n  /**\n   * Substract this from another Vector.\n   * @param v Another vector\n   */\n  public sub( vector: T ): T {\n    return this.__new( vecSub( this.elements, vector.elements ) );\n  }\n\n  /**\n   * Multiply one or more Vector with this.\n   * @param vectors Other Vectors\n   */\n  public multiply( ...vectors: T[] ): T {\n    return this.__new( vecMultiply( this.elements, ...vectors.map( ( v ) => v.elements ) ) );\n  }\n\n  /**\n   * Divide this from another Vector.\n   * @param vector Another Vector\n   */\n  public divide( vector: T ): T {\n    return this.__new( vecDivide( this.elements, vector.elements ) );\n  }\n\n  /**\n   * Scale this by scalar.\n   * a.k.a. `multiplyScalar`\n   * @param scalar A scalar\n   */\n  public scale( scalar: number ): T {\n    return this.__new( vecScale( this.elements, scalar ) );\n  }\n\n  /**\n   * Dot two Vectors.\n   * @param vector Another vector\n   */\n  public dot( vector: T ): number {\n    return vecDot( this.elements, vector.elements );\n  }\n\n  protected abstract __new( v: number[] ): T;\n}\n", "import type { RawMatrix4 } from '../mat4';\nimport type { RawVector4 } from './RawVector4';\n\n/**\n * Multiply a vec4 by a mat4.\n */\nexport function vec4ApplyMatrix4( v: RawVector4, m: RawMatrix4 ): RawVector4 {\n  return [\n    m[ 0 ] * v[ 0 ] + m[ 4 ] * v[ 1 ] + m[ 8 ] * v[ 2 ] + m[ 12 ] * v[ 3 ],\n    m[ 1 ] * v[ 0 ] + m[ 5 ] * v[ 1 ] + m[ 9 ] * v[ 2 ] + m[ 13 ] * v[ 3 ],\n    m[ 2 ] * v[ 0 ] + m[ 6 ] * v[ 1 ] + m[ 10 ] * v[ 2 ] + m[ 14 ] * v[ 3 ],\n    m[ 3 ] * v[ 0 ] + m[ 7 ] * v[ 1 ] + m[ 11 ] * v[ 2 ] + m[ 15 ] * v[ 3 ],\n  ];\n}\n", "import { vec4ApplyMatrix4 } from '../vec4/vec4ApplyMatrix4';\nimport { vecScale } from '../vec/vecScale';\nimport type { RawMatrix4 } from '../mat4/RawMatrix4';\nimport type { RawVector3 } from './RawVector3';\n\n/**\n * Apply a vec3 (with an implicit 1 in the 4th dimension) a mat4.\n */\nexport function vec3ApplyMatrix4( v: RawVector3, m: RawMatrix4 ): RawVector3 {\n  const vec4 = vec4ApplyMatrix4( [ ...v, 1 ], m );\n  const xyz: RawVector3 = [ vec4[ 0 ], vec4[ 1 ], vec4[ 2 ] ];\n  const w = vec4[ 3 ];\n  return vecScale( xyz, 1.0 / w );\n}\n", "import type { RawQuaternion } from './RawQuaternion';\n\n/**\n * Return an inverse of a quaternion.\n */\nexport function quatInverse( quat: RawQuaternion ): RawQuaternion {\n  return [ -quat[ 0 ], -quat[ 1 ], -quat[ 2 ], quat[ 3 ] ];\n}\n", "import type { RawQuaternion } from './RawQuaternion';\n\n/**\n * Return a multiplication result of quaternions.\n */\nexport function quatMultiply( ...quats: RawQuaternion[] ): RawQuaternion {\n  if ( quats.length < 2 ) {\n    return quats[ 0 ];\n  }\n\n  const a = quats.shift()!;\n  const b = quatMultiply( ...quats );\n\n  return [\n    a[ 3 ] * b[ 0 ] + a[ 0 ] * b[ 3 ] + a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ],\n    a[ 3 ] * b[ 1 ] - a[ 0 ] * b[ 2 ] + a[ 1 ] * b[ 3 ] + a[ 2 ] * b[ 0 ],\n    a[ 3 ] * b[ 2 ] + a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] + a[ 2 ] * b[ 3 ],\n    a[ 3 ] * b[ 3 ] - a[ 0 ] * b[ 0 ] - a[ 1 ] * b[ 1 ] - a[ 2 ] * b[ 2 ],\n  ];\n}\n", "import { quatInverse } from '../quat/quatInverse';\nimport { quatMultiply } from '../quat/quatMultiply';\nimport type { RawQuaternion } from '../quat/RawQuaternion';\nimport type { RawVector3 } from './RawVector3';\n\n/**\n * Apply a vec3 (with an implicit 1 in the 4th dimension) a quaternion.\n */\nexport function vec3ApplyQuaternion( vec: RawVector3, quat: RawQuaternion ): RawVector3 {\n  const p: RawQuaternion = [ ...vec, 0.0 ];\n  const r = quatInverse( quat );\n  const res = quatMultiply( quat, p, r );\n  res.pop();\n  return res as unknown as RawVector3;\n}\n", "import type { RawVector3 } from './RawVector3';\n\n/**\n * Return a cross product of two vec3s.\n */\nexport function vec3Cross( vecA: RawVector3, vecB: RawVector3 ): RawVector3 {\n  return [\n    vecA[ 1 ] * vecB[ 2 ] - vecA[ 2 ] * vecB[ 1 ],\n    vecA[ 2 ] * vecB[ 0 ] - vecA[ 0 ] * vecB[ 2 ],\n    vecA[ 0 ] * vecB[ 1 ] - vecA[ 1 ] * vecB[ 0 ],\n  ];\n}\n", "import { vec3Cross } from './vec3Cross';\nimport { vecDot } from '../vec/vecDot';\nimport { vecNeg } from '../vec/vecNeg';\nimport { vecNormalize } from '../vec/vecNormalize';\nimport { vecScale } from '../vec/vecScale';\nimport { vecSub } from '../vec/vecSub';\nimport type { RawVector3 } from './RawVector3';\n\n/**\n * Return a tangent which is orthogonal to normal.\n * If binormal is specified, it is also returned and it's orthogonal to both normal and tangent.\n */\nexport function vec3OrthoNormalize(\n  normal: RawVector3,\n  tangent: RawVector3 = [ 0.0, 1.0, 0.0 ],\n  binormal?: RawVector3,\n): {\n    normal: RawVector3,\n    tangent: RawVector3,\n    binormal: RawVector3,\n  } {\n  const n = vecNormalize( normal );\n  let t = vecNormalize( tangent );\n\n  let dotNT = vecDot( n, t );\n\n  if ( dotNT === 1.0 ) {\n    if ( Math.abs( n[ 1 ] ) > Math.abs( n[ 2 ] ) ) {\n      t = [ 0.0, 0.0, 1.0 ];\n    } else {\n      t = [ 0.0, 1.0, 0.0 ];\n    }\n    dotNT = vecDot( n, t );\n  }\n\n  t = vecNormalize( vecSub( t, vecScale( n, dotNT ) ) );\n\n  let b = vec3Cross( t, n );\n  if ( binormal && vecDot( b, binormal ) < 0.0 ) {\n    b = vecNeg( b );\n  }\n\n  return {\n    normal: n,\n    tangent: t,\n    binormal: b,\n  };\n}\n", "import { Matrix4 } from '../mat4/Matrix4';\nimport { Quaternion } from '../quat/Quaternion';\nimport { Vector } from '../vec/Vector';\nimport { vec3ApplyMatrix4 } from './vec3ApplyMatrix4';\nimport { vec3ApplyQuaternion } from './vec3ApplyQuaternion';\nimport { vec3Cross } from './vec3Cross';\nimport { vec3OrthoNormalize } from './vec3OrthoNormalize';\nimport type { RawVector3 } from './RawVector3';\n\n/**\n * A Vector3.\n */\nexport class Vector3 extends Vector<Vector3> {\n  public elements: RawVector3;\n\n  public constructor( v: RawVector3 = [ 0.0, 0.0, 0.0 ] ) {\n    super();\n    this.elements = v;\n  }\n\n  /**\n   * An x component of this.\n   */\n  public get x(): number {\n    return this.elements[ 0 ];\n  }\n\n  public set x( x: number ) {\n    this.elements[ 0 ] = x;\n  }\n\n  /**\n   * An y component of this.\n   */\n  public get y(): number {\n    return this.elements[ 1 ];\n  }\n\n  public set y( y: number ) {\n    this.elements[ 1 ] = y;\n  }\n\n  /**\n   * An z component of this.\n   */\n  public get z(): number {\n    return this.elements[ 2 ];\n  }\n\n  public set z( z: number ) {\n    this.elements[ 2 ] = z;\n  }\n\n  public toString(): string {\n    return `Vector3( ${ this.x.toFixed( 3 ) }, ${ this.y.toFixed( 3 ) }, ${ this.z.toFixed( 3 ) } )`;\n  }\n\n  /**\n   * Return a cross of this and another Vector3.\n   * @param vector Another vector\n   */\n  public cross( vector: Vector3 ): Vector3 {\n    return new Vector3( vec3Cross( this.elements, vector.elements ) );\n  }\n\n  /**\n   * Rotate this vector using a Quaternion.\n   * @param quaternion A quaternion\n   */\n  public applyQuaternion( quaternion: Quaternion ): Vector3 {\n    return new Vector3( vec3ApplyQuaternion( this.elements, quaternion.elements ) );\n  }\n\n  /**\n   * Multiply this vector (with an implicit 1 in the 4th dimension) by m.\n   */\n  public applyMatrix4( matrix: Matrix4 ): Vector3 {\n    return new Vector3( vec3ApplyMatrix4( this.elements, matrix.elements ) );\n  }\n\n  protected __new( v: RawVector3 ): Vector3 {\n    return new Vector3( v );\n  }\n\n  /**\n   * Vector3( 0.0, 0.0, 0.0 )\n   */\n  public static get zero(): Vector3 {\n    return new Vector3( [ 0.0, 0.0, 0.0 ] );\n  }\n\n  /**\n   * Vector3( 1.0, 0.0, 0.0 )\n   */\n  public static get px(): Vector3 {\n    return new Vector3( [ 1.0, 0.0, 0.0 ] );\n  }\n\n  /**\n   * Vector3( -1.0, 0.0, 0.0 )\n   */\n  public static get nx(): Vector3 {\n    return new Vector3( [ -1.0, 0.0, 0.0 ] );\n  }\n\n  /**\n   * Vector3( 0.0, 1.0, 0.0 )\n   */\n  public static get py(): Vector3 {\n    return new Vector3( [ 0.0, 1.0, 0.0 ] );\n  }\n\n  /**\n   * Vector3( 0.0, -1.0, 0.0 )\n   */\n  public static get ny(): Vector3 {\n    return new Vector3( [ 0.0, -1.0, 0.0 ] );\n  }\n\n  /**\n   * Vector3( 0.0, 0.0, 1.0 )\n   */\n  public static get pz(): Vector3 {\n    return new Vector3( [ 0.0, 0.0, 1.0 ] );\n  }\n\n  /**\n   * Vector3( 0.0, 0.0, -1.0 )\n   */\n  public static get nz(): Vector3 {\n    return new Vector3( [ 0.0, 0.0, -1.0 ] );\n  }\n\n  /**\n   * Vector3( 1.0, 1.0, 1.0 )\n   */\n  public static get one(): Vector3 {\n    return new Vector3( [ 1.0, 1.0, 1.0 ] );\n  }\n\n  /**\n   * Return a tangent which is orthogonal to normal.\n   * If binormal is specified, it is also returned and it's orthogonal to both normal and tangent.\n   */\n  public static orthoNormalize( normal: Vector3, tangent: Vector3, binormal: Vector3 ): {\n    normal: Vector3,\n    tangent: Vector3,\n    binormal: Vector3,\n  } {\n    const result = vec3OrthoNormalize( normal.elements, tangent.elements, binormal.elements );\n    return {\n      normal: new Vector3( result.normal ),\n      tangent: new Vector3( result.tangent ),\n      binormal: new Vector3( result.binormal ),\n    };\n  }\n}\n", "import type { RawBox3 } from './RawBox3';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Test if given point is contained in given box or not.\n * @param box A box\n * @param point A point\n */\nexport function box3ContainsPoint( box: RawBox3, point: RawVector3 ): boolean {\n  return (\n    box[ 0 ][ 0 ] <= point[ 0 ] &&\n    box[ 1 ][ 0 ] >= point[ 0 ] &&\n    box[ 0 ][ 1 ] <= point[ 1 ] &&\n    box[ 1 ][ 1 ] >= point[ 1 ] &&\n    box[ 0 ][ 2 ] <= point[ 2 ] &&\n    box[ 1 ][ 2 ] >= point[ 2 ]\n  );\n}\n", "import { Vector3 } from '../vec3/Vector3';\nimport { box3ContainsPoint } from './box3ContainsPoint';\nimport type { RawBox3 } from './RawBox3';\n\n/**\n * A 3D box.\n */\nexport class Box3 {\n  public min: Vector3;\n  public max: Vector3;\n\n  public constructor( min: Vector3 = Vector3.zero, max: Vector3 = Vector3.zero ) {\n    this.min = min;\n    this.max = max;\n  }\n\n  /**\n   * Itself but {@link RawBox3} form.\n   */\n  public get raw(): RawBox3 {\n    return [ this.min.elements, this.max.elements ];\n  }\n\n  /**\n   * Test if given point is contained in the box or not.\n   *\n   * @param point A point\n   */\n  public containsPoint( point: Vector3 ): boolean {\n    return box3ContainsPoint( this.raw, point.elements );\n  }\n\n  /**\n   * Convert {@link RawBox3} to class form.\n   * @param box A {@link RawBox3}\n   */\n  public static fromRaw( box: RawBox3 ): Box3 {\n    return new Box3( new Vector3( box[ 0 ] ), new Vector3( box[ 1 ] ) );\n  }\n}\n", "import type { RawMatrix3 } from './RawMatrix3';\nimport type { RawMatrix4 } from '../mat4/RawMatrix4';\n\n/**\n * Who needs this?\n *\n * Intended to be used by {@link mat3CreateNormalMatrix}.\n */\nexport function mat3FromMat4Transpose(\n  source: RawMatrix4,\n): RawMatrix3 {\n  return [\n    source[ 0 ], source[ 4 ], source[ 8 ],\n    source[ 1 ], source[ 5 ], source[ 9 ],\n    source[ 2 ], source[ 6 ], source[ 10 ],\n  ];\n}\n", "import { vecScale } from '../vec/vecScale';\nimport type { RawMatrix3 } from './RawMatrix3';\n\n/**\n * Return an inverse of given mat3.\n *\n * Yoinked from Three.js\n */\nexport function mat3Inverse( m: RawMatrix3 ): RawMatrix3 {\n  const\n    n11 = m[ 0 ], n21 = m[ 1 ], n31 = m[ 2 ],\n    n12 = m[ 3 ], n22 = m[ 4 ], n32 = m[ 5 ],\n    n13 = m[ 6 ], n23 = m[ 7 ], n33 = m[ 8 ],\n    t11 = n33 * n22 - n32 * n23,\n    t12 = n32 * n13 - n33 * n12,\n    t13 = n23 * n12 - n22 * n13,\n    det = n11 * t11 + n21 * t12 + n31 * t13;\n\n  if ( det === 0.0 ) { return vecScale( m, 0.0 ); }\n\n  return vecScale( [\n    t11,\n    n31 * n23 - n33 * n21,\n    n32 * n21 - n31 * n22,\n    t12,\n    n33 * n11 - n31 * n13,\n    n31 * n12 - n32 * n11,\n    t13,\n    n21 * n13 - n23 * n11,\n    n22 * n11 - n21 * n12,\n  ], 1.0 / det );\n}\n", "import { mat3FromMat4Transpose } from './mat3FromMat4Transpose';\nimport { mat3Inverse } from './mat3Inverse';\nimport type { RawMatrix3 } from './RawMatrix3';\nimport type { RawMatrix4 } from '../mat4/RawMatrix4';\n\n/**\n * Create a normal matrix out of a matrix4.\n *\n * @param matrix A matrix4\n */\nexport function mat3CreateNormalMatrix( m: RawMatrix4 ): RawMatrix3 {\n  return mat3Inverse( mat3FromMat4Transpose( m ) );\n}\n", "import type { RawMatrix3 } from './RawMatrix3';\n\nexport function mat3Determinant( m: RawMatrix3 ): number {\n  const\n    n11 = m[ 0 ], n21 = m[ 1 ], n31 = m[ 2 ],\n    n12 = m[ 3 ], n22 = m[ 4 ], n32 = m[ 5 ],\n    n13 = m[ 6 ], n23 = m[ 7 ], n33 = m[ 8 ],\n    t11 = n33 * n22 - n32 * n23,\n    t12 = n32 * n13 - n33 * n12,\n    t13 = n23 * n12 - n22 * n13;\n\n  return n11 * t11 + n21 * t12 + n31 * t13;\n}\n", "import type { RawMatrix3 } from './RawMatrix3';\nimport type { RawMatrix4 } from '../mat4/RawMatrix4';\n\n/**\n * Create a matrix3 from matrix4.\n */\nexport function mat3FromMat4(\n  source: RawMatrix4,\n): RawMatrix3 {\n  return [\n    source[ 0 ], source[ 1 ], source[ 2 ],\n    source[ 4 ], source[ 5 ], source[ 6 ],\n    source[ 8 ], source[ 9 ], source[ 10 ],\n  ];\n}\n", "import type { RawMatrix3 } from './RawMatrix3';\nimport type { RawQuaternion } from '../quat/RawQuaternion';\n\n/**\n * Convert a quaternion into a matrix3.\n *\n * Yoinked from Three.js.\n *\n * See: https://threejs.org/docs/#api/en/math/Matrix4.makeRotationFromQuaternion\n */\nexport function mat3FromQuaternion( quat: RawQuaternion ): RawMatrix3 {\n  const x = quat[ 0 ];\n  const y = quat[ 1 ];\n  const z = quat[ 2 ];\n  const w = quat[ 3 ];\n\n  return [\n    1.0 - 2.0 * y * y - 2.0 * z * z, 2.0 * x * y + 2.0 * z * w, 2.0 * x * z - 2.0 * y * w,\n    2.0 * x * y - 2.0 * z * w, 1.0 - 2.0 * x * x - 2.0 * z * z, 2.0 * y * z + 2.0 * x * w,\n    2.0 * x * z + 2.0 * y * w, 2.0 * y * z - 2.0 * x * w, 1.0 - 2.0 * x * x - 2.0 * y * y,\n  ];\n}\n", "import type { RawMatrix3 } from './RawMatrix3';\n\n/**\n * Return a multiplication result of matrices.\n */\nexport function mat3Multiply( ...mats: RawMatrix3[] ): RawMatrix3 {\n  if ( mats.length < 2 ) {\n    return mats[ 0 ];\n  }\n\n  const a = mats.shift()!;\n  const b = mat3Multiply( ...mats );\n  const\n    a00 = a[ 0 ], a01 = a[ 1 ], a02 = a[ 2 ],\n    a10 = a[ 3 ], a11 = a[ 4 ], a12 = a[ 5 ],\n    a20 = a[ 6 ], a21 = a[ 7 ], a22 = a[ 8 ],\n    b00 = b[ 0 ], b01 = b[ 1 ], b02 = b[ 2 ],\n    b10 = b[ 3 ], b11 = b[ 4 ], b12 = b[ 5 ],\n    b20 = b[ 6 ], b21 = b[ 7 ], b22 = b[ 8 ];\n\n  return [\n    a00 * b00 + a10 * b01 + a20 * b02,\n    a01 * b00 + a11 * b01 + a21 * b02,\n    a02 * b00 + a12 * b01 + a22 * b02,\n\n    a00 * b10 + a10 * b11 + a20 * b12,\n    a01 * b10 + a11 * b11 + a21 * b12,\n    a02 * b10 + a12 * b11 + a22 * b12,\n\n    a00 * b20 + a10 * b21 + a20 * b22,\n    a01 * b20 + a11 * b21 + a21 * b22,\n    a02 * b20 + a12 * b21 + a22 * b22,\n  ];\n}\n", "import type { RawMatrix3 } from './RawMatrix3';\n\n/**\n * Transpose a mat3.\n */\nexport function mat3Transpose(\n  source: RawMatrix3,\n): RawMatrix3 {\n  return [\n    source[ 0 ], source[ 3 ], source[ 6 ],\n    source[ 1 ], source[ 4 ], source[ 7 ],\n    source[ 2 ], source[ 5 ], source[ 8 ],\n  ];\n}\n", "import { Matrix4 } from '../mat4/Matrix4';\nimport { Quaternion } from '../quat/Quaternion';\nimport { mat3CreateNormalMatrix } from './mat3CreateNormalMatrix';\nimport { mat3Determinant } from './mat3Determinant';\nimport { mat3FromMat4 } from './mat3FromMat4';\nimport { mat3FromQuaternion } from './mat3FromQuaternion';\nimport { mat3Inverse } from './mat3Inverse';\nimport { mat3Multiply } from './mat3Multiply';\nimport { mat3Transpose } from './mat3Transpose';\nimport { vecScale } from '../vec/vecScale';\nimport type { RawMatrix3 } from './RawMatrix3';\n\nconst rawIdentityMatrix3: RawMatrix3 = [\n  1.0, 0.0, 0.0,\n  0.0, 1.0, 0.0,\n  0.0, 0.0, 1.0,\n];\n\n/**\n * A Matrix3.\n */\nexport class Matrix3 {\n  public elements: RawMatrix3;\n\n  public constructor( v: RawMatrix3 = rawIdentityMatrix3 ) {\n    this.elements = v;\n  }\n\n  /**\n   * Itself but transposed.\n   */\n  public get transpose(): Matrix3 {\n    return new Matrix3( mat3Transpose( this.elements ) );\n  }\n\n  /**\n   * Its determinant.\n   */\n  public get determinant(): number {\n    return mat3Determinant( this.elements );\n  }\n\n  /**\n   * Itself but inverted.\n   */\n  public get inverse(): Matrix3 {\n    return new Matrix3( mat3Inverse( this.elements ) );\n  }\n\n  /**\n   * Itself but matrix4.\n   */\n  public get matrix4(): Matrix4 {\n    return Matrix4.fromMatrix3( this );\n  }\n\n  public toString(): string {\n    const m = this.elements.map( ( v ) => v.toFixed( 3 ) );\n    return `Matrix3( ${ m[ 0 ] }, ${ m[ 3 ] }, ${ m[ 6 ] }; ${ m[ 1 ] }, ${ m[ 4 ] }, ${ m[ 7 ] }; ${ m[ 2 ] }, ${ m[ 5 ] }, ${ m[ 8 ] } )`;\n  }\n\n  /**\n   * Clone this.\n   */\n  public clone(): Matrix3 {\n    return new Matrix3( this.elements.concat() as RawMatrix3 );\n  }\n\n  /**\n   * Multiply this Matrix3 by one or more Matrix3s.\n   */\n  public multiply( ...matrices: Matrix3[] ): Matrix3 {\n    return Matrix3.multiply( this, ...matrices );\n  }\n\n  /**\n   * Multiply this Matrix3 by a scalar.\n   */\n  public scaleScalar( scalar: number ): Matrix3 {\n    return new Matrix3( vecScale( this.elements, scalar ) );\n  }\n\n  /**\n   * An identity Matrix4.\n   */\n  public static get identity(): Matrix3 {\n    return new Matrix3( rawIdentityMatrix3 );\n  }\n\n  /**\n   * Multiply two or more matrices.\n   * @param matrices Matrices\n   */\n  public static multiply( ...matrices: Matrix3[] ): Matrix3 {\n    if ( matrices.length === 0 ) {\n      return Matrix3.identity;\n    } else {\n      return new Matrix3( mat3Multiply( ...matrices.map( ( m ) => m.elements ) ) );\n    }\n  }\n\n  /**\n   * Create a normal matrix out of matrix4.\n   * @param matrix4 A matrix4\n   */\n  public static createNormalMatrix( matrix4: Matrix4 ): Matrix3 {\n    return new Matrix3( mat3CreateNormalMatrix( matrix4.elements ) );\n  }\n\n  /**\n   * Cast a {@link Matrix4} into a Matrix3.\n   * @param matrix4 A matrix4\n   */\n  public static fromMatrix4( matrix4: Matrix4 ): Matrix3 {\n    return new Matrix3( mat3FromMat4( matrix4.elements ) );\n  }\n\n  /**\n   * Create a matrix out of a {@link Quaternion}.\n   * @param quaternion A quaternion\n   */\n  public static fromQuaternion( quaternion: Quaternion ): Matrix3 {\n    return new Matrix3( mat3FromQuaternion( quaternion.elements ) );\n  }\n}\n", "import type { RawMatrix4 } from '.';\nimport type { RawQuaternion } from '../quat/RawQuaternion';\n\n/**\n * Convert a quaternion into a matrix4.\n *\n * Yoinked from Three.js.\n *\n * See: https://threejs.org/docs/#api/en/math/Matrix4.makeRotationFromQuaternion\n */\nexport function mat4FromQuaternion( quat: RawQuaternion ): RawMatrix4 {\n  const x = quat[ 0 ];\n  const y = quat[ 1 ];\n  const z = quat[ 2 ];\n  const w = quat[ 3 ];\n\n  return [\n    1.0 - 2.0 * y * y - 2.0 * z * z, 2.0 * x * y + 2.0 * z * w, 2.0 * x * z - 2.0 * y * w, 0.0,\n    2.0 * x * y - 2.0 * z * w, 1.0 - 2.0 * x * x - 2.0 * z * z, 2.0 * y * z + 2.0 * x * w, 0.0,\n    2.0 * x * z + 2.0 * y * w, 2.0 * y * z - 2.0 * x * w, 1.0 - 2.0 * x * x - 2.0 * y * y, 0.0,\n    0.0, 0.0, 0.0, 1.0,\n  ];\n}\n", "import { mat4FromQuaternion } from './mat4FromQuaternion';\nimport type { RawMatrix4 } from './RawMatrix4';\nimport type { RawQuaternion } from '../quat/RawQuaternion';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Compose a matrix out of position, scale, and rotation.\n * Yoinked from Three.js.\n */\nexport function mat4Compose(\n  position: RawVector3,\n  rotation: RawQuaternion,\n  scale: RawVector3,\n): RawMatrix4 {\n  const matRot = mat4FromQuaternion( rotation );\n\n  const sx = scale[ 0 ], sy = scale[ 1 ], sz = scale[ 2 ];\n\n  return [\n    matRot[ 0 ] * sx,\n    matRot[ 1 ] * sx,\n    matRot[ 2 ] * sx,\n    0.0,\n\n    matRot[ 4 ] * sy,\n    matRot[ 5 ] * sy,\n    matRot[ 6 ] * sy,\n    0.0,\n\n    matRot[ 8 ] * sz,\n    matRot[ 9 ] * sz,\n    matRot[ 10 ] * sz,\n    0.0,\n\n    position[ 0 ],\n    position[ 1 ],\n    position[ 2 ],\n    1.0\n  ];\n}\n", "import type { RawMatrix4 } from './RawMatrix4';\n\n/**\n * Return a determinant of given mat4.\n */\nexport function mat4Determinant( m: RawMatrix4 ): number {\n  const\n    a00 = m[  0 ], a01 = m[  1 ], a02 = m[  2 ], a03 = m[  3 ],\n    a10 = m[  4 ], a11 = m[  5 ], a12 = m[  6 ], a13 = m[  7 ],\n    a20 = m[  8 ], a21 = m[  9 ], a22 = m[ 10 ], a23 = m[ 11 ],\n    a30 = m[ 12 ], a31 = m[ 13 ], a32 = m[ 14 ], a33 = m[ 15 ],\n    b00 = a00 * a11 - a01 * a10,  b01 = a00 * a12 - a02 * a10,\n    b02 = a00 * a13 - a03 * a10,  b03 = a01 * a12 - a02 * a11,\n    b04 = a01 * a13 - a03 * a11,  b05 = a02 * a13 - a03 * a12,\n    b06 = a20 * a31 - a21 * a30,  b07 = a20 * a32 - a22 * a30,\n    b08 = a20 * a33 - a23 * a30,  b09 = a21 * a32 - a22 * a31,\n    b10 = a21 * a33 - a23 * a31,  b11 = a22 * a33 - a23 * a32;\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n", "import type { RawMatrix3 } from '../mat3/RawMatrix3';\nimport type { RawQuaternion } from './RawQuaternion';\n\n/**\n * Generate a Quaternion out of a rotation matrix.\n * Yoinked from Three.js.\n */\nexport function quatFromMatrix3( m: RawMatrix3 ): RawQuaternion {\n  const m11 = m[ 0 ], m12 = m[ 3 ], m13 = m[ 6 ],\n    m21 = m[ 1 ], m22 = m[ 4 ], m23 = m[ 7 ],\n    m31 = m[ 2 ], m32 = m[ 5 ], m33 = m[ 8 ],\n    trace = m11 + m22 + m33;\n\n  if ( trace > 0 ) {\n    const s = 0.5 / Math.sqrt( trace + 1.0 );\n    return [\n      ( m32 - m23 ) * s,\n      ( m13 - m31 ) * s,\n      ( m21 - m12 ) * s,\n      0.25 / s\n    ];\n  } else if ( m11 > m22 && m11 > m33 ) {\n    const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n    return [\n      0.25 * s,\n      ( m12 + m21 ) / s,\n      ( m13 + m31 ) / s,\n      ( m32 - m23 ) / s\n    ];\n  } else if ( m22 > m33 ) {\n    const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n    return [\n      ( m12 + m21 ) / s,\n      0.25 * s,\n      ( m23 + m32 ) / s,\n      ( m13 - m31 ) / s\n    ];\n  } else {\n    const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n    return [\n      ( m13 + m31 ) / s,\n      ( m23 + m32 ) / s,\n      0.25 * s,\n      ( m21 - m12 ) / s\n    ];\n  }\n}\n", "import { mat3FromMat4 } from '../mat3/mat3FromMat4';\nimport { quatFromMatrix3 } from './quatFromMatrix3';\nimport type { RawMatrix4 } from '../mat4/RawMatrix4';\nimport type { RawQuaternion } from './RawQuaternion';\n\n/**\n * Generate a Quaternion out of a rotation matrix.\n */\nexport function quatFromMatrix4( m: RawMatrix4 ): RawQuaternion {\n  return quatFromMatrix3( mat3FromMat4( m ) );\n}\n", "import { mat4Determinant } from './mat4Determinant';\nimport { quatFromMatrix4 } from '../quat/quatFromMatrix4';\nimport { vecLength } from '../vec/vecLength';\nimport type { RawMatrix4 } from './RawMatrix4';\nimport type { RawQuaternion } from '../quat/RawQuaternion';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Decompose a matrix into a position, a scale, and a rotation.\n * Yoinked from Three.js.\n */\nexport function mat4Decompose( m: RawMatrix4 ): {\n  position: RawVector3;\n  scale: RawVector3;\n  rotation: RawQuaternion;\n} {\n  let sx = vecLength( [ m[ 0 ], m[ 1 ], m[ 2 ] ] );\n  const sy = vecLength( [ m[ 4 ], m[ 5 ], m[ 6 ] ] );\n  const sz = vecLength( [ m[ 8 ], m[ 9 ], m[ 10 ] ] );\n\n  // if determinant is negative, we need to invert one scale\n  const det = mat4Determinant( m );\n  if ( det < 0 ) { sx = -sx; }\n\n  const invSx = 1.0 / sx;\n  const invSy = 1.0 / sy;\n  const invSz = 1.0 / sz;\n\n  const rotationMatrix = m.concat() as RawMatrix4;\n\n  rotationMatrix[ 0 ] *= invSx;\n  rotationMatrix[ 1 ] *= invSx;\n  rotationMatrix[ 2 ] *= invSx;\n\n  rotationMatrix[ 4 ] *= invSy;\n  rotationMatrix[ 5 ] *= invSy;\n  rotationMatrix[ 6 ] *= invSy;\n\n  rotationMatrix[ 8 ] *= invSz;\n  rotationMatrix[ 9 ] *= invSz;\n  rotationMatrix[ 10 ] *= invSz;\n\n  return {\n    position: [ m[ 12 ], m[ 13 ], m[ 14 ] ],\n    scale: [ sx, sy, sz ],\n    rotation: quatFromMatrix4( rotationMatrix ),\n  };\n}\n", "import type { RawMatrix3 } from '../mat3/RawMatrix3';\nimport type { RawMatrix4 } from './RawMatrix4';\n\n/**\n * Create a matrix4 from matrix3.\n */\nexport function mat4FromMat3(\n  source: RawMatrix3,\n): RawMatrix4 {\n  return [\n    source[ 0 ], source[ 1 ], source[ 2 ], 0.0,\n    source[ 3 ], source[ 4 ], source[ 5 ], 0.0,\n    source[ 6 ], source[ 7 ], source[ 8 ], 0.0,\n    0.0, 0.0, 0.0, 1.0,\n  ];\n}\n", "import { vecScale } from '../vec/vecScale';\nimport type { RawMatrix4 } from './RawMatrix4';\n\n/**\n *  an inverse of given mat4.\n */\nexport function mat4Inverse( m: RawMatrix4 ): RawMatrix4 {\n  const\n    a00 = m[  0 ], a01 = m[  1 ], a02 = m[  2 ], a03 = m[  3 ],\n    a10 = m[  4 ], a11 = m[  5 ], a12 = m[  6 ], a13 = m[  7 ],\n    a20 = m[  8 ], a21 = m[  9 ], a22 = m[ 10 ], a23 = m[ 11 ],\n    a30 = m[ 12 ], a31 = m[ 13 ], a32 = m[ 14 ], a33 = m[ 15 ],\n    b00 = a00 * a11 - a01 * a10,  b01 = a00 * a12 - a02 * a10,\n    b02 = a00 * a13 - a03 * a10,  b03 = a01 * a12 - a02 * a11,\n    b04 = a01 * a13 - a03 * a11,  b05 = a02 * a13 - a03 * a12,\n    b06 = a20 * a31 - a21 * a30,  b07 = a20 * a32 - a22 * a30,\n    b08 = a20 * a33 - a23 * a30,  b09 = a21 * a32 - a22 * a31,\n    b10 = a21 * a33 - a23 * a31,  b11 = a22 * a33 - a23 * a32;\n\n  const det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if ( det === 0.0 ) { return vecScale( m, 0.0 ); }\n\n  return vecScale( [\n    a11 * b11 - a12 * b10 + a13 * b09,\n    a02 * b10 - a01 * b11 - a03 * b09,\n    a31 * b05 - a32 * b04 + a33 * b03,\n    a22 * b04 - a21 * b05 - a23 * b03,\n    a12 * b08 - a10 * b11 - a13 * b07,\n    a00 * b11 - a02 * b08 + a03 * b07,\n    a32 * b02 - a30 * b05 - a33 * b01,\n    a20 * b05 - a22 * b02 + a23 * b01,\n    a10 * b10 - a11 * b08 + a13 * b06,\n    a01 * b08 - a00 * b10 - a03 * b06,\n    a30 * b04 - a31 * b02 + a33 * b00,\n    a21 * b02 - a20 * b04 - a23 * b00,\n    a11 * b07 - a10 * b09 - a12 * b06,\n    a00 * b09 - a01 * b07 + a02 * b06,\n    a31 * b01 - a30 * b03 - a32 * b00,\n    a20 * b03 - a21 * b01 + a22 * b00,\n  ], 1.0 / det );\n}\n", "import { vec3Cross } from '../vec3/vec3Cross';\nimport { vecAdd } from '../vec/vecAdd';\nimport { vecNormalize } from '../vec/vecNormalize';\nimport { vecScale } from '../vec/vecScale';\nimport { vecSub } from '../vec/vecSub';\nimport type { RawMatrix4 } from './RawMatrix4';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Generate a \"LookAt\" matrix.\n *\n * See also: {@link mat4LookAtInverse}\n */\nexport function mat4LookAt(\n  position: RawVector3,\n  target: RawVector3 = [ 0.0, 0.0, 0.0 ],\n  up: RawVector3 = [ 0.0, 1.0, 0.0 ],\n  roll = 0.0,\n): RawMatrix4 {\n  const dir = vecNormalize( vecSub( position, target ) );\n\n  let sid = vecNormalize( vec3Cross( up, dir ) );\n\n  if ( roll !== 0.0 ) {\n    sid = vecAdd(\n      vecScale( sid, Math.cos( roll ) ),\n      vecScale( vec3Cross( dir, sid ), Math.sin( roll ) ),\n    );\n  }\n\n  const top = vec3Cross( dir, sid );\n\n  return [\n    sid[ 0 ], sid[ 1 ], sid[ 2 ], 0.0,\n    top[ 0 ], top[ 1 ], top[ 2 ], 0.0,\n    dir[ 0 ], dir[ 1 ], dir[ 2 ], 0.0,\n    position[ 0 ], position[ 1 ], position[ 2 ], 1.0\n  ];\n}\n", "import { vec3Cross } from '../vec3/vec3Cross';\nimport { vecAdd } from '../vec/vecAdd';\nimport { vecDot } from '../vec/vecDot';\nimport { vecNormalize } from '../vec/vecNormalize';\nimport { vecScale } from '../vec/vecScale';\nimport { vecSub } from '../vec/vecSub';\nimport type { RawMatrix4 } from './RawMatrix4';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Generate an inverse of \"LookAt\" matrix. Good for creating a view matrix.\n *\n * See also: {@link mat4LookAt}\n */\nexport function mat4LookAtInverse(\n  position: RawVector3,\n  target: RawVector3 = [ 0.0, 0.0, 0.0 ],\n  up: RawVector3 = [ 0.0, 1.0, 0.0 ],\n  roll = 0.0,\n): RawMatrix4 {\n  const dir = vecNormalize( vecSub( position, target ) );\n\n  let sid = vecNormalize( vec3Cross( up, dir ) );\n\n  if ( roll !== 0.0 ) {\n    sid = vecAdd(\n      vecScale( sid, Math.cos( roll ) ),\n      vecScale( vec3Cross( dir, sid ), Math.sin( roll ) ),\n    );\n  }\n\n  const top = vec3Cross( dir, sid );\n\n  return [\n    sid[ 0 ], top[ 0 ], dir[ 0 ], 0.0,\n    sid[ 1 ], top[ 1 ], dir[ 1 ], 0.0,\n    sid[ 2 ], top[ 2 ], dir[ 2 ], 0.0,\n    -vecDot( sid, position ),\n    -vecDot( top, position ),\n    -vecDot( dir, position ),\n    1.0,\n  ];\n}\n", "import type { RawMatrix4 } from './RawMatrix4';\n\n/**\n * Return a multiplication result of matrices.\n */\nexport function mat4Multiply( ...mats: RawMatrix4[] ): RawMatrix4 {\n  if ( mats.length < 2 ) {\n    return mats[ 0 ];\n  }\n\n  const a = mats.shift()!;\n  const b = mat4Multiply( ...mats );\n  const\n    a00 = a[  0 ], a01 = a[  1 ], a02 = a[  2 ], a03 = a[  3 ],\n    a10 = a[  4 ], a11 = a[  5 ], a12 = a[  6 ], a13 = a[  7 ],\n    a20 = a[  8 ], a21 = a[  9 ], a22 = a[ 10 ], a23 = a[ 11 ],\n    a30 = a[ 12 ], a31 = a[ 13 ], a32 = a[ 14 ], a33 = a[ 15 ],\n    b00 = b[  0 ], b01 = b[  1 ], b02 = b[  2 ], b03 = b[  3 ],\n    b10 = b[  4 ], b11 = b[  5 ], b12 = b[  6 ], b13 = b[  7 ],\n    b20 = b[  8 ], b21 = b[  9 ], b22 = b[ 10 ], b23 = b[ 11 ],\n    b30 = b[ 12 ], b31 = b[ 13 ], b32 = b[ 14 ], b33 = b[ 15 ];\n\n  return [\n    a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03,\n    a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03,\n    a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03,\n    a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03,\n\n    a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13,\n    a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13,\n    a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13,\n    a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13,\n\n    a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23,\n    a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23,\n    a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23,\n    a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23,\n\n    a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33,\n    a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33,\n    a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33,\n    a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33,\n  ];\n}\n", "import type { RawMatrix4 } from './RawMatrix4';\n\n/**\n * Generate a \"Perspective\" projection matrix.\n *\n * @param fov Field of View Y, **IN DEGREES**\n * @param near Near clip plane\n * @param far Far clip plane\n * @param aspect Aspect ratio. **`1.0` BY DEFAULT**\n */\nexport function mat4Perspective(\n  fov = 45.0,\n  near = 0.01,\n  far = 100.0,\n  aspect = 1.0,\n): RawMatrix4 {\n  const p = 1.0 / Math.tan( fov * Math.PI / 360.0 );\n  const d = ( far - near );\n  return [\n    p / aspect, 0.0, 0.0, 0.0,\n    0.0, p, 0.0, 0.0,\n    0.0, 0.0, -( far + near ) / d, -1.0,\n    0.0, 0.0, -2 * far * near / d, 0.0\n  ];\n}\n", "import type { RawMatrix4 } from './RawMatrix4';\n\n/**\n * Generate a 3d rotation matrix, rotates around x axis.\n */\nexport function mat4RotationX( theta: number ): RawMatrix4 {\n  const c = Math.cos( theta );\n  const s = Math.sin( theta );\n\n  return [\n    1, 0, 0, 0,\n    0, c, -s, 0,\n    0, s, c, 0,\n    0, 0, 0, 1,\n  ];\n}\n", "import type { RawMatrix4 } from './RawMatrix4';\n\n/**\n * Generate a 3d rotation matrix, rotates around y axis.\n */\nexport function mat4RotationY( theta: number ): RawMatrix4 {\n  const c = Math.cos( theta );\n  const s = Math.sin( theta );\n\n  return [\n    c, 0, s, 0,\n    0, 1, 0, 0,\n    -s, 0, c, 0,\n    0, 0, 0, 1,\n  ];\n}\n", "import type { RawMatrix4 } from './RawMatrix4';\n\n/**\n * Generate a 3d rotation matrix, rotates around z axis.\n */\nexport function mat4RotationZ( theta: number ): RawMatrix4 {\n  const c = Math.cos( theta );\n  const s = Math.sin( theta );\n\n  return [\n    c, -s, 0, 0,\n    s, c, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1,\n  ];\n}\n", "import type { RawMatrix4 } from './RawMatrix4';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Generate a 3d scaling matrix.\n */\nexport function mat4Scale( vec: RawVector3 ): RawMatrix4 {\n  return [\n    vec[ 0 ], 0, 0, 0,\n    0, vec[ 1 ], 0, 0,\n    0, 0, vec[ 2 ], 0,\n    0, 0, 0, 1,\n  ];\n}\n", "import type { RawMatrix4 } from './RawMatrix4';\n\n/**\n * Generate a 3d scaling matrix by a scalar.\n */\nexport function mat4ScaleScalar( scalar: number ): RawMatrix4 {\n  return [\n    scalar, 0, 0, 0,\n    0, scalar, 0, 0,\n    0, 0, scalar, 0,\n    0, 0, 0, 1,\n  ];\n}\n", "import type { RawMatrix4 } from './RawMatrix4';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Generate a translation matrix.\n */\nexport function mat4Translate( vec: RawVector3 ): RawMatrix4 {\n  return [\n    1, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, 1, 0,\n    vec[ 0 ], vec[ 1 ], vec[ 2 ], 1\n  ];\n}\n", "import type { RawMatrix4 } from './RawMatrix4';\n\n/**\n * Transpose a mat4.\n */\nexport function mat4Transpose( m: RawMatrix4 ): RawMatrix4 {\n  return [\n    m[ 0 ], m[ 4 ], m[ 8 ], m[ 12 ],\n    m[ 1 ], m[ 5 ], m[ 9 ], m[ 13 ],\n    m[ 2 ], m[ 6 ], m[ 10 ], m[ 14 ],\n    m[ 3 ], m[ 7 ], m[ 11 ], m[ 15 ],\n  ];\n}\n", "import { Matrix3 } from '../mat3/Matrix3';\nimport { Quaternion } from '../quat/Quaternion';\nimport { Vector3 } from '../vec3/Vector3';\nimport { mat4Compose } from './mat4Compose';\nimport { mat4Decompose } from './mat4Decompose';\nimport { mat4Determinant } from './mat4Determinant';\nimport { mat4FromMat3 } from './mat4FromMat3';\nimport { mat4FromQuaternion } from './mat4FromQuaternion';\nimport { mat4Inverse } from './mat4Inverse';\nimport { mat4LookAt } from './mat4LookAt';\nimport { mat4LookAtInverse } from './mat4LookAtInverse';\nimport { mat4Multiply } from './mat4Multiply';\nimport { mat4Perspective } from './mat4Perspective';\nimport { mat4RotationX } from './mat4RotationX';\nimport { mat4RotationY } from './mat4RotationY';\nimport { mat4RotationZ } from './mat4RotationZ';\nimport { mat4Scale } from './mat4Scale';\nimport { mat4ScaleScalar } from './mat4ScaleScalar';\nimport { mat4Translate } from './mat4Translate';\nimport { mat4Transpose } from './mat4Transpose';\nimport { vecScale } from '../vec/vecScale';\nimport type { RawMatrix4 } from './RawMatrix4';\n\nconst rawIdentityMatrix4: RawMatrix4 = [\n  1.0, 0.0, 0.0, 0.0,\n  0.0, 1.0, 0.0, 0.0,\n  0.0, 0.0, 1.0, 0.0,\n  0.0, 0.0, 0.0, 1.0\n];\n\n/**\n * A Matrix4.\n */\nexport class Matrix4 {\n  public elements: RawMatrix4;\n\n  public constructor( v: RawMatrix4 = rawIdentityMatrix4 ) {\n    this.elements = v;\n  }\n\n  /**\n   * Itself but transposed.\n   */\n  public get transpose(): Matrix4 {\n    return new Matrix4( mat4Transpose( this.elements ) );\n  }\n\n  /**\n   * Its determinant.\n   */\n  public get determinant(): number {\n    return mat4Determinant( this.elements );\n  }\n\n  /**\n   * Itself but inverted.\n   */\n  public get inverse(): Matrix4 {\n    return new Matrix4( mat4Inverse( this.elements ) );\n  }\n\n  /**\n   * Itself but matrix3.\n   */\n  public get matrix3(): Matrix3 {\n    return Matrix3.fromMatrix4( this );\n  }\n\n  /**\n   * Itself but normal matrix.\n   */\n  public get normalMatrix(): Matrix3 {\n    return Matrix3.createNormalMatrix( this );\n  }\n\n  public toString(): string {\n    const m = this.elements.map( ( v ) => v.toFixed( 3 ) );\n    return `Matrix4( ${ m[ 0 ] }, ${ m[ 4 ] }, ${ m[ 8 ] }, ${ m[ 12 ] }; ${ m[ 1 ] }, ${ m[ 5 ] }, ${ m[ 9 ] }, ${ m[ 13 ] }; ${ m[ 2 ] }, ${ m[ 6 ] }, ${ m[ 10 ] }, ${ m[ 14 ] }; ${ m[ 3 ] }, ${ m[ 7 ] }, ${ m[ 11 ] }, ${ m[ 15 ] } )`;\n  }\n\n  /**\n   * Clone this.\n   */\n  public clone(): Matrix4 {\n    return new Matrix4( this.elements.concat() as RawMatrix4 );\n  }\n\n  /**\n   * Multiply this Matrix4 by one or more Matrix4s.\n   */\n  public multiply( ...matrices: Matrix4[] ): Matrix4 {\n    return Matrix4.multiply( this, ...matrices );\n  }\n\n  /**\n   * Multiply this Matrix4 by a scalar.\n   */\n  public scaleScalar( scalar: number ): Matrix4 {\n    return new Matrix4( vecScale( this.elements, scalar ) );\n  }\n\n  /**\n   * Decompose this matrix into a position, a scale, and a rotation.\n   */\n  public decompose(): { position: Vector3; scale: Vector3; rotation: Quaternion } {\n    const { position, scale, rotation } = mat4Decompose( this.elements );\n\n    return {\n      position: new Vector3( position ),\n      scale: new Vector3( scale ),\n      rotation: new Quaternion( rotation ),\n    };\n  }\n\n  /**\n   * An identity Matrix4.\n   */\n  public static get identity(): Matrix4 {\n    return new Matrix4( rawIdentityMatrix4 );\n  }\n\n  /**\n   * Multiply two or more matrices.\n   * @param matrices Matrices\n   */\n  public static multiply( ...matrices: Matrix4[] ): Matrix4 {\n    if ( matrices.length === 0 ) {\n      return Matrix4.identity;\n    } else {\n      return new Matrix4( mat4Multiply( ...matrices.map( ( m ) => m.elements ) ) );\n    }\n  }\n\n  /**\n   * Create a matrix out of a {@link Quaternion}.\n   * @param quaternion A quaternion\n   */\n  public static fromQuaternion( quaternion: Quaternion ): Matrix4 {\n    return new Matrix4( mat4FromQuaternion( quaternion.elements ) );\n  }\n\n  /**\n   * Cast a {@link Matrix3} into a Matrix4.\n   * @param matrix3 A matrix3\n   */\n  public static fromMatrix3( matrix3: Matrix3 ): Matrix4 {\n    return new Matrix4( mat4FromMat3( matrix3.elements ) );\n  }\n\n  /**\n   * Generate a translation matrix.\n   * @param vector Translation\n   */\n  public static translate( vector: Vector3 ): Matrix4 {\n    return new Matrix4( mat4Translate( vector.elements ) );\n  }\n\n  /**\n   * Generate a 3d scaling matrix.\n   * @param vector Scale\n   */\n  public static scale( vector: Vector3 ): Matrix4 {\n    return new Matrix4( mat4Scale( vector.elements ) );\n  }\n\n  /**\n   * Generate a 3d scaling matrix by a scalar.\n   * @param vector Scale\n   */\n  public static scaleScalar( scalar: number ): Matrix4 {\n    return new Matrix4( mat4ScaleScalar( scalar ) );\n  }\n\n  /**\n   * Generate a 3d rotation matrix, rotates around x axis.\n   * @param vector Scale\n   */\n  public static rotationX( theta: number ): Matrix4 {\n    return new Matrix4( mat4RotationX( theta ) );\n  }\n\n  /**\n   * Generate a 3d rotation matrix, rotates around y axis.\n   * @param vector Scale\n   */\n  public static rotationY( theta: number ): Matrix4 {\n    return new Matrix4( mat4RotationY( theta ) );\n  }\n\n  /**\n   * Generate a 3d rotation matrix, rotates around z axis.\n   * @param vector Scale\n   */\n  public static rotationZ( theta: number ): Matrix4 {\n    return new Matrix4( mat4RotationZ( theta ) );\n  }\n\n  /**\n   * Generate a \"LookAt\" matrix.\n   *\n   * See also: {@link lookAtInverse}\n   */\n  public static lookAt(\n    position: Vector3,\n    target = new Vector3( [ 0.0, 0.0, 0.0 ] ),\n    up = new Vector3( [ 0.0, 1.0, 0.0 ] ),\n    roll = 0.0\n  ): Matrix4 {\n    return new Matrix4( mat4LookAt(\n      position.elements,\n      target.elements,\n      up.elements,\n      roll,\n    ) );\n  }\n\n  /**\n   * Generate an inverse of \"LookAt\" matrix. Good for creating a view matrix.\n   *\n   * See also: {@link lookAt}\n   */\n  public static lookAtInverse(\n    position: Vector3,\n    target = new Vector3( [ 0.0, 0.0, 0.0 ] ),\n    up = new Vector3( [ 0.0, 1.0, 0.0 ] ),\n    roll = 0.0\n  ): Matrix4 {\n    return new Matrix4( mat4LookAtInverse(\n      position.elements,\n      target.elements,\n      up.elements,\n      roll,\n    ) );\n  }\n\n  /**\n   * Generate a \"Perspective\" projection matrix.\n   * It won't include aspect!\n   */\n  public static perspective( fov = 45.0, near = 0.01, far = 100.0 ): Matrix4 {\n    return new Matrix4( mat4Perspective( fov, near, far ) );\n  }\n\n  /**\n   * Compose a matrix out of position, scale, and rotation.\n   * Yoinked from Three.js.\n   */\n  public static compose( position: Vector3, rotation: Quaternion, scale: Vector3 ): Matrix4 {\n    return new Matrix4( mat4Compose( position.elements, rotation.elements, scale.elements ) );\n  }\n}\n", "import type { RawQuaternion } from './RawQuaternion';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Generate a Quaternion out of axis and angle.\n */\nexport function quatFromAxisAngle( axis: RawVector3, angle: number ): RawQuaternion {\n  const halfAngle = angle / 2.0;\n  const sinHalfAngle = Math.sin( halfAngle );\n  return [\n    axis[ 0 ] * sinHalfAngle,\n    axis[ 1 ] * sinHalfAngle,\n    axis[ 2 ] * sinHalfAngle,\n    Math.cos( halfAngle )\n  ];\n}\n", "import { vec3OrthoNormalize } from '../vec3/vec3OrthoNormalize';\nimport type { RawQuaternion } from './RawQuaternion';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Return a quaternion which looks at the direction of `look`.\n */\nexport function quatLookRotation( look: RawVector3, up?: RawVector3 ): RawQuaternion {\n  const { normal, tangent, binormal } = vec3OrthoNormalize( look, up ?? [ 0.0, 1.0, 0.0 ] );\n\n  const w = Math.sqrt( 1.0 + binormal[ 0 ] + tangent[ 1 ] + normal[ 2 ] ) * 0.5;\n  const invW4 = 0.25 / w;\n\n  return [\n    ( tangent[ 2 ] - normal[ 1 ] ) * invW4,\n    ( normal[ 0 ] - binormal[ 2 ] ) * invW4,\n    ( binormal[ 1 ] - tangent[ 0 ] ) * invW4,\n    w,\n  ];\n}\n", "import { vecLength } from '../vec/vecLength';\nimport { vecScale } from '../vec/vecScale';\nimport type { RawQuaternion } from './RawQuaternion';\n\n/**\n * Normalize given quaternion.\n *\n * It's almost identical as {@link vecNormalize},\n * but it will return an identity quaternion instead\n * when it recieves a quaternion which length is zero.\n */\nexport function quatNormalize( vec: RawQuaternion ): RawQuaternion {\n  const len = vecLength( vec );\n  if ( len === 0.0 ) {\n    return [ 0.0, 0.0, 0.0, 1.0 ];\n  }\n  return vecScale( vec, 1.0 / len );\n}\n", "import type { RawQuaternion } from './RawQuaternion';\n\n/**\n * Generate a quaternion rotates around x axis.\n * @param theta An angle around x axis, in degree\n */\nexport function quatRotationX( theta: number ): RawQuaternion {\n  return [ Math.sin( theta / 2.0 ), 0.0, 0.0, Math.cos( theta / 2.0 ) ];\n}\n", "import type { RawQuaternion } from './RawQuaternion';\n\n/**\n * Generate a quaternion rotates around y axis.\n * @param theta An angle around y axis, in degree\n */\nexport function quatRotationY( theta: number ): RawQuaternion {\n  return [ 0.0, Math.sin( theta / 2.0 ), 0.0, Math.cos( theta / 2.0 ) ];\n}\n", "import type { RawQuaternion } from './RawQuaternion';\n\n/**\n * Generate a quaternion rotates around z axis.\n * @param theta An angle around z axis, in degree\n */\nexport function quatRotationZ( theta: number ): RawQuaternion {\n  return [ 0.0, 0.0, Math.sin( theta / 2.0 ), Math.cos( theta / 2.0 ) ];\n}\n", "import { vecDot, vecNeg, vecNormalize } from '..';\nimport type { RawQuaternion } from './RawQuaternion';\n\n/**\n * Interpolate between two quaternions.\n * @param a \"from\" quaternion\n * @param b \"to\" quaternion\n * @param t How much do we want to rotate the a to b\n */\nexport function quatSlerp( a: RawQuaternion, b: RawQuaternion, t: number ): RawQuaternion {\n  if ( t === 0.0 ) { return a.concat() as RawQuaternion; }\n  if ( t === 1.0 ) { return b.concat() as RawQuaternion; }\n\n  // Ref: https://github.com/mrdoob/three.js/blob/master/src/math/Quaternion.js\n  // Ref: http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n  let cosHalfTheta = vecDot( a, b );\n\n  if ( cosHalfTheta < 0.0 ) {\n    b = vecNeg( b );\n    cosHalfTheta = -cosHalfTheta;\n  }\n\n  // I think you two are same\n  if ( cosHalfTheta >= 1.0 ) {\n    return a.concat() as RawQuaternion;\n  }\n\n  const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n\n  // fallback to simple lerp\n  if ( sqrSinHalfTheta <= Number.EPSILON ) {\n    const s = 1.0 - t;\n\n    return vecNormalize( [\n      s * a[ 0 ] + t * b[ 0 ],\n      s * a[ 1 ] + t * b[ 1 ],\n      s * a[ 2 ] + t * b[ 2 ],\n      s * a[ 3 ] + t * b[ 3 ],\n    ] );\n  }\n\n  // welcome\n  const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );\n  const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n  const ratioA = Math.sin( ( 1.0 - t ) * halfTheta ) / sinHalfTheta;\n  const ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n  return [\n    a[ 0 ] * ratioA + b[ 0 ] * ratioB,\n    a[ 1 ] * ratioA + b[ 1 ] * ratioB,\n    a[ 2 ] * ratioA + b[ 2 ] * ratioB,\n    a[ 3 ] * ratioA + b[ 3 ] * ratioB,\n  ];\n}\n", "import { Matrix4 } from '../mat4/Matrix4';\nimport { Vector3 } from '../vec3/Vector3';\nimport { mat4FromQuaternion } from '../mat4/mat4FromQuaternion';\nimport { quatFromAxisAngle } from './quatFromAxisAngle';\nimport { quatFromMatrix4 } from './quatFromMatrix4';\nimport { quatInverse } from './quatInverse';\nimport { quatLookRotation } from './quatLookRotation';\nimport { quatMultiply } from './quatMultiply';\nimport { quatNormalize } from './quatNormalize';\nimport { quatRotationX } from './quatRotationX';\nimport { quatRotationY } from './quatRotationY';\nimport { quatRotationZ } from './quatRotationZ';\nimport { quatSlerp } from './quatSlerp';\nimport { vecLength } from '../vec/vecLength';\nimport { vecLengthSq } from '../vec/vecLengthSq';\nimport type { RawQuaternion } from './RawQuaternion';\n\nconst rawIdentityQuaternion: RawQuaternion = [ 0.0, 0.0, 0.0, 1.0 ];\n\n/**\n * A Quaternion.\n */\nexport class Quaternion {\n  public elements: RawQuaternion; // [ x, y, z; w ]\n\n  public constructor( elements: RawQuaternion = rawIdentityQuaternion ) {\n    this.elements = elements;\n  }\n\n  /**\n   * An x component of this.\n   */\n  public get x(): number {\n    return this.elements[ 0 ];\n  }\n\n  /**\n   * An y component of this.\n   */\n  public get y(): number {\n    return this.elements[ 1 ];\n  }\n\n  /**\n   * An z component of this.\n   */\n  public get z(): number {\n    return this.elements[ 2 ];\n  }\n\n  /**\n   * An w component of this.\n   */\n  public get w(): number {\n    return this.elements[ 3 ];\n  }\n\n  public toString(): string {\n    return `Quaternion( ${ this.x.toFixed( 3 ) }, ${ this.y.toFixed( 3 ) }, ${ this.z.toFixed( 3 ) }, ${ this.w.toFixed( 3 ) } )`;\n  }\n\n  /**\n   * Clone this.\n   */\n  public clone(): Quaternion {\n    return new Quaternion( this.elements.concat() as RawQuaternion );\n  }\n\n  /**\n   * Itself but converted into a Matrix4.\n   */\n  public get matrix4(): Matrix4 {\n    return new Matrix4( mat4FromQuaternion( this.elements ) );\n  }\n\n  /**\n   * An inverse of this.\n   */\n  public get inversed(): Quaternion {\n    return new Quaternion( quatInverse( this.elements ) );\n  }\n\n  /**\n   * The length of this.\n   */\n  public get length(): number {\n    return vecLength( this.elements );\n  }\n\n  /**\n   * The squared length of this.\n   */\n  public get lengthSq(): number {\n    return vecLengthSq( this.elements );\n  }\n\n  /**\n   * A normalized this.\n   */\n  public get normalized(): Quaternion {\n    return new Quaternion( quatNormalize( this.elements ) );\n  }\n\n  /**\n   * Multiply one or more Quaternions with this.\n   * @param quaternions Other Quaternions\n   */\n  public multiply( ...quaternions: Quaternion[] ): Quaternion {\n    return Quaternion.multiply( this, ...quaternions );\n  }\n\n  /**\n   * Interpolate between this and given quaternion.\n   * @param b Another Quaternion\n   * @param t How much do we want to rotate this to b\n   */\n  public slerp( b: Quaternion, t: number ): Quaternion {\n    return Quaternion.slerp( this, b, t );\n  }\n\n  /**\n   * An identity Quaternion.\n   */\n  public static get identity(): Quaternion {\n    return new Quaternion( rawIdentityQuaternion );\n  }\n\n  /**\n   * Multiply two or more matrices.\n   * @param quaternion Quaternions\n   */\n  public static multiply( ...quaternions: Quaternion[] ): Quaternion {\n    if ( quaternions.length === 0 ) {\n      return Quaternion.identity;\n    } else {\n      return new Quaternion( quatMultiply( ...quaternions.map( ( q ) => q.elements ) ) );\n    }\n  }\n\n  /**\n   * Interpolate between two quaternions.\n   * @param a \"from\" quaternion\n   * @param b \"to\" quaternion\n   * @param t How much do we want to rotate the a to b\n   */\n  public static slerp( a: Quaternion, b: Quaternion, t: number ): Quaternion {\n    return new Quaternion( quatSlerp( a.elements, b.elements, t ) );\n  }\n\n  /**\n   * Return a quaternion which rotates around x axis.\n   * @param theta An angle around x axis, in degree\n   */\n  public static rotationX( theta: number ): Quaternion {\n    return new Quaternion( quatRotationX( theta ) );\n  }\n\n  /**\n   * Return a quaternion which rotates around y axis.\n   * @param theta An angle around y axis, in degree\n   */\n  public static rotationY( theta: number ): Quaternion {\n    return new Quaternion( quatRotationY( theta ) );\n  }\n\n  /**\n   * Return a quaternion which rotates around z axis.\n   * @param theta An angle around z axis, in degree\n   */\n  public static rotationZ( theta: number ): Quaternion {\n    return new Quaternion( quatRotationZ( theta ) );\n  }\n\n  /**\n   * Return a quaternion which looks at the direction of `look`.\n   * @param look Position where the quaternion will look at\n   * @param up The \"up vector\"\n   */\n  public static lookRotation( look: Vector3, up: Vector3 ): Quaternion {\n    return new Quaternion( quatLookRotation( look.elements, up.elements ) );\n  }\n\n  /**\n   * Generate a Quaternion out of angle and axis.\n   */\n  public static fromAxisAngle( axis: Vector3, angle: number ): Quaternion {\n    return new Quaternion( quatFromAxisAngle( axis.elements, angle ) );\n  }\n\n  /**\n   * Generate a Quaternion out of a rotation matrix.\n   */\n  public static fromMatrix4( matrix: Matrix4 ): Quaternion {\n    return new Quaternion( quatFromMatrix4( matrix.elements ) );\n  }\n}\n", "/**\n * GLSL Style `mod` function.\n * \"compute value of one parameter modulo another\"\n */\nexport function mod( value: number, divisor: number ): number {\n  return value - Math.floor( value / divisor ) * divisor;\n}\n", "import { mod } from './mod';\n\n/**\n * Enclose arbitrary angle (in radian) into [-\u03C0, \u03C0)\n */\nexport function sanitizeAngle( angle: number ): number {\n  return mod( angle + Math.PI, 2.0 * Math.PI ) - Math.PI;\n}\n", "import { clamp } from '../utils';\nimport { sanitizeAngle } from '../sanitizeAngle';\nimport { vecManhattanLength } from '../vec/vecManhattanLength';\nimport type { EulerOrder } from './EulerOrder';\nimport type { RawMatrix3 } from '../mat3/RawMatrix3';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Return a euler angles out of a matrix3.\n * Make sure the input matrix is normalized.\n *\n * @param m An input rotation matrix\n * @param order An order of output euler angles. Assume as `XYZ` if not specified\n */\nexport function eulerFromMat3( m: RawMatrix3, order?: EulerOrder ): RawVector3 {\n  const [ i, j, k, sign ] =\n    !order || order === 'XYZ' ? [ 0, 1, 2, 1 ] :\n    order === 'XZY' ? [ 0, 2, 1, -1 ] :\n    order === 'YXZ' ? [ 1, 0, 2, -1 ] :\n    order === 'YZX' ? [ 1, 2, 0, 1 ] :\n    order === 'ZXY' ? [ 2, 0, 1, 1 ] :\n    [ 2, 1, 0, -1 ];\n\n  const result: RawVector3 = [ 0.0, 0.0, 0.0 ];\n\n  const c = m[ k + i * 3 ];\n  result[ j ] = -sign * Math.asin( clamp( c, -1.0, 1.0 ) );\n\n  if ( Math.abs( c ) < 0.999999 ) {\n    result[ i ] = sign * Math.atan2( m[ k + j * 3 ], m[ k * 4 ] );\n    result[ k ] = sign * Math.atan2( m[ j + i * 3 ], m[ i * 4 ] );\n  } else {\n    // \"y is 90deg\" cases\n    result[ i ] = sign * Math.atan2( -m[ j + k * 3 ], m[ j * 4 ] );\n  }\n\n  if ( vecManhattanLength( result ) > 1.5 * Math.PI ) {\n    // \"two big revolutions\" cases\n    result[ i ] = sanitizeAngle( result[ i ] + Math.PI );\n    result[ j ] = sanitizeAngle( Math.PI - result[ j ] );\n    result[ k ] = sanitizeAngle( result[ k ] + Math.PI );\n  }\n\n  return result;\n}\n", "import { eulerFromMat3 } from './eulerFromMat3';\nimport { mat3FromMat4 } from '../mat3/mat3FromMat4';\nimport type { EulerOrder } from './EulerOrder';\nimport type { RawMatrix4 } from '../mat4/RawMatrix4';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Return a euler angles out of a matrix4.\n * Make sure the input matrix is normalized.\n *\n * @param m An input rotation matrix\n * @param order An order of output euler angles. Assume as `XYZ` if not specified\n */\nexport function eulerFromMat4( m: RawMatrix4, order?: EulerOrder ): RawVector3 {\n  return eulerFromMat3( mat3FromMat4( m ), order );\n}\n", "import { eulerFromMat3 } from './eulerFromMat3';\nimport { mat3FromQuaternion } from '../mat3/mat3FromQuaternion';\nimport type { EulerOrder } from './EulerOrder';\nimport type { RawQuaternion } from '../quat/RawQuaternion';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Return a euler angles out of a quaternion.\n *\n * @param m An input quaternion\n * @param order An order of output euler angles. Assume as `XYZ` if not specified\n */\nexport function eulerFromQuaternion( m: RawQuaternion, order?: EulerOrder ): RawVector3 {\n  return eulerFromMat3( mat3FromQuaternion( m ), order );\n}\n", "import type { EulerOrder } from '../euler/EulerOrder';\nimport type { RawQuaternion } from './RawQuaternion';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Generate a Quaternion out of euler angles.\n */\nexport function quatFromEuler( euler: RawVector3, order?: EulerOrder ): RawQuaternion {\n  const [ i, j, k, sign ] =\n    !order || order === 'XYZ' ? [ 0, 1, 2, 1 ] :\n    order === 'XZY' ? [ 0, 2, 1, -1 ] :\n    order === 'YXZ' ? [ 1, 0, 2, -1 ] :\n    order === 'YZX' ? [ 1, 2, 0, 1 ] :\n    order === 'ZXY' ? [ 2, 0, 1, 1 ] :\n    [ 2, 1, 0, -1 ];\n\n  const ti = 0.5 * euler[ i ];\n  const tj = 0.5 * sign * euler[ j ];\n  const tk = 0.5 * euler[ k ];\n\n  const ci = Math.cos( ti );\n  const cj = Math.cos( tj );\n  const ck = Math.cos( tk );\n  const si = Math.sin( ti );\n  const sj = Math.sin( tj );\n  const sk = Math.sin( tk );\n\n  const result: RawQuaternion = [\n    0.0,\n    0.0,\n    0.0,\n    ck * cj * ci + sk * sj * si,\n  ];\n  result[ i ] = ck * cj * si - sk * sj * ci;\n  result[ j ] = sign * ( ck * sj * ci + sk * cj * si );\n  result[ k ] = sk * cj * ci - ck * sj * si;\n\n  return result;\n}\n", "import { Matrix3 } from '../mat3/Matrix3';\nimport { Matrix4 } from '../mat4/Matrix4';\nimport { Quaternion } from '../quat/Quaternion';\nimport { eulerFromMat3 } from './eulerFromMat3';\nimport { eulerFromMat4 } from './eulerFromMat4';\nimport { eulerFromQuaternion } from './eulerFromQuaternion';\nimport { quatFromEuler } from '../quat/quatFromEuler';\nimport type { EulerOrder } from './EulerOrder';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * An Euler rotations.\n */\nexport class Euler {\n  public elements: RawVector3; // [ x, y, z ]\n\n  /**\n   * An order of this euler.\n   * 'XYZ' by default.\n   *\n   * Note that this is **extrinsic** rotations (which is same as Blender, Maya, and Unity).\n   * Three.js uses intrinsic rotations so you have to reverse the order if you want to match the behavior with Three.js.\n   */\n  public order: EulerOrder;\n\n  public constructor( elements: RawVector3 = [ 0.0, 0.0, 0.0 ], order: EulerOrder = 'XYZ' ) {\n    this.elements = elements;\n    this.order = order;\n  }\n\n  /**\n   * An x component of this.\n   */\n  public get x(): number {\n    return this.elements[ 0 ];\n  }\n\n  /**\n   * An y component of this.\n   */\n  public get y(): number {\n    return this.elements[ 1 ];\n  }\n\n  /**\n   * An z component of this.\n   */\n  public get z(): number {\n    return this.elements[ 2 ];\n  }\n\n  public toString(): string {\n    return `Euler( ${ this.x.toFixed( 3 ) }, ${ this.y.toFixed( 3 ) }, ${ this.z.toFixed( 3 ) } (${ this.order }) )`;\n  }\n\n  /**\n   * Clone this.\n   */\n  public clone(): Euler {\n    return new Euler( this.elements.concat() as RawVector3, this.order );\n  }\n\n  /**\n   * Itself but converted into a Quaternion.\n   */\n  public get quaternion(): Quaternion {\n    return new Quaternion( quatFromEuler( this.elements, this.order ) );\n  }\n\n  /**\n   * Itself but converted into a Matrix4.\n   */\n  public get matrix4(): Matrix4 {\n    return this.quaternion.matrix4;\n  }\n\n  /**\n   * Generate an Euler out of a matrix3.\n   */\n  public static fromMatrix3( matrix: Matrix3, order: EulerOrder ): Euler {\n    return new Euler( eulerFromMat3( matrix.elements, order ), order );\n  }\n\n  /**\n   * Generate an Euler out of a matrix4.\n   */\n  public static fromMatrix4( matrix: Matrix4, order: EulerOrder ): Euler {\n    return new Euler( eulerFromMat4( matrix.elements, order ), order );\n  }\n\n  /**\n   * Generate an Euler out of a quaternion.\n   */\n  public static fromQuaternion( quaternion: Quaternion, order: EulerOrder ): Euler {\n    return new Euler( eulerFromQuaternion( quaternion.elements, order ), order );\n  }\n}\n", "import { vecDot } from '../vec/vecDot';\nimport { vecSub } from '../vec/vecSub';\nimport type { RawRay3 } from './RawRay3';\nimport type { RawSphere3 } from '../sphere3/RawSphere3';\n\n/**\n * Return distances from given ray to sphere.\n *\n * The returning distance can be negative.\n *\n * The first returning value will be the distance of the incident point.\n * If the ray does not intersect with sphere, it will return `null`.\n *\n * @param ray A ray\n * @param sphere A target sphere\n */\nexport function ray3DistanceToSphere(\n  [ ro, rd ]: RawRay3,\n  sphere: RawSphere3,\n): [ number, number ] | null {\n  const v = vecSub( ro, sphere[ 0 ] );\n  const b = vecDot( v, rd );\n  const c = vecDot( v, v ) - sphere[ 1 ];\n  const d = b * b - c;\n\n  if ( d < 0.0 ) { return null; }\n\n  const sqrtD = Math.sqrt( d );\n\n  return [ -b - sqrtD, -b + sqrtD ];\n}\n", "import { vecSub } from '../vec/vecSub';\nimport type { RawLine3 } from './RawLine3';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Return a vector that represents delta of given line.\n *\n * @param line A line\n */\nexport function line3Delta( line: RawLine3 ): RawVector3 {\n  return vecSub( line[ 1 ], line[ 0 ] );\n}\n", "import { line3Delta } from '../line3/line3Delta';\nimport { vecNormalize } from '../vec/vecNormalize';\nimport type { RawLine3 } from '../line3/RawLine3';\nimport type { RawRay3 } from './RawRay3';\n\n/**\n * Convert the given line to a ray.\n *\n * @param line A line\n */\nexport function ray3FromLine3( line: RawLine3 ): RawRay3 {\n  return [\n    line[ 0 ],\n    vecNormalize( line3Delta( line ) ),\n  ];\n}\n", "import { Line3 } from '../line3/Line3';\nimport { Sphere3 } from '../sphere3/Sphere3';\nimport { Vector3 } from '../vec3/Vector3';\nimport { ray3DistanceToSphere } from './ray3DistanceToSphere';\nimport { ray3FromLine3 } from './ray3FromLine3';\nimport type { RawRay3 } from './RawRay3';\n\n/**\n * A 3D ray.\n */\nexport class Ray3 {\n  /**\n   * The origin of the ray.\n   */\n  public origin: Vector3;\n\n  /**\n   * The direction of the ray.\n   * Make sure the direction is normalized.\n   */\n  public direction: Vector3;\n\n  public constructor( start: Vector3 = Vector3.zero, end: Vector3 = Vector3.pz ) {\n    this.origin = start;\n    this.direction = end;\n  }\n\n  /**\n   * Itself but {@link RawRay3} form.\n   */\n  public get raw(): RawRay3 {\n    return [ this.origin.elements, this.direction.elements ];\n  }\n\n  /**\n   * Return distances from given ray to sphere.\n   *\n   * The returning distance can be negative.\n   *\n   * The first returning value will be the distance of the incident point.\n   * If the ray does not intersect with sphere, it will return `null`.\n   *\n   * @param sphere A target sphere\n   */\n  public distanceToSphere( sphere: Sphere3 ): [ number, number ] | null {\n    return ray3DistanceToSphere( this.raw, sphere.raw );\n  }\n\n  /**\n   * Convert {@link RawRay3} to class form.\n   * @param ray A {@link RawRay3}\n   */\n  public static fromRaw( ray: RawRay3 ): Ray3 {\n    return new Ray3( new Vector3( ray[ 0 ] ), new Vector3( ray[ 1 ] ) );\n  }\n\n  /**\n   * Create a ray out of a line.\n   *\n   * @param line A {@link Line3}\n   */\n  public static fromLine3( line: Line3 ): Ray3 {\n    return Ray3.fromRaw( ray3FromLine3( line.raw ) );\n  }\n}\n", "import { vec3ApplyMatrix4 } from '../vec3/vec3ApplyMatrix4';\nimport type { RawLine3 } from './RawLine3';\nimport type { RawMatrix4 } from '../mat4/RawMatrix4';\n\n/**\n * Apply given matrix4 to given line.\n *\n * @param line A line\n * @param matrix A matrix4 which will be applied to the line\n */\nexport function line3ApplyMatrix4(\n  [ start, end ]: RawLine3,\n  matrix: RawMatrix4,\n): RawLine3 {\n  return [\n    vec3ApplyMatrix4( start, matrix ),\n    vec3ApplyMatrix4( end, matrix ),\n  ];\n}\n", "import { vecAdd } from '../vec/vecAdd';\nimport { vecScale } from '../vec/vecScale';\nimport type { RawLine3 } from './RawLine3';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Return a vector that represents a certain point of given line.\n * Same as start at t = 0, same as end at t = 1.\n *\n * @param line A line\n * @param t A parameter t\n */\nexport function line3At( line: RawLine3, t: number ): RawVector3 {\n  return vecAdd(\n    vecScale( line[ 0 ], 1.0 - t ),\n    vecScale( line[ 1 ], t ),\n  );\n}\n", "import { line3At } from './line3At';\nimport { saturate } from '../utils';\nimport { vecDot } from '../vec/vecDot';\nimport { vecSub } from '../vec/vecSub';\nimport type { RawLine3 } from './RawLine3';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Return a point that is on the given line which is closest to the given point.\n *\n * If `segment` is true, it will treat the line as a segment which has start and end.\n * Otherwise it will treat the line is infinite.\n *\n * @param line A line\n * @param point A point\n * @param segment Is the line a segment?\n */\nexport function line3ClosestPointToPoint(\n  line: RawLine3,\n  point: RawVector3,\n  segment?: boolean,\n): RawVector3 {\n  const ap = vecSub( point, line[ 0 ] );\n  const ab = vecSub( line[ 1 ], line[ 0 ] );\n\n  let t = vecDot( ap, ab ) / vecDot( ab, ab );\n  segment && ( t = saturate( t ) );\n\n  return line3At( line, t );\n}\n", "import { line3ClosestPointToPoint } from './line3ClosestPointToPoint';\nimport { vecLength } from '../vec/vecLength';\nimport { vecSub } from '../vec/vecSub';\nimport type { RawLine3 } from './RawLine3';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Return a distance from the given line to the given point.\n *\n * If `segment` is true, it will treat the line as a segment which has start and end.\n * Otherwise it will treat the line is infinite.\n *\n * @param line A line\n * @param point A point\n * @param segment Is the line a segment?\n */\nexport function line3DistanceToPoint(\n  line: RawLine3,\n  point: RawVector3,\n  segment?: boolean,\n): number {\n  return vecLength( vecSub(\n    line3ClosestPointToPoint( line, point, segment ),\n    point,\n  ) );\n}\n", "import { Matrix4 } from '../mat4/Matrix4';\nimport { Ray3 } from '../ray3/Ray3';\nimport { Vector3 } from '../vec3/Vector3';\nimport { line3ApplyMatrix4 } from './line3ApplyMatrix4';\nimport { line3At } from './line3At';\nimport { line3ClosestPointToPoint } from './line3ClosestPointToPoint';\nimport { line3Delta } from './line3Delta';\nimport { line3DistanceToPoint } from './line3DistanceToPoint';\nimport type { RawLine3 } from './RawLine3';\n\n/**\n * A 3D line.\n */\nexport class Line3 {\n  public start: Vector3;\n  public end: Vector3;\n\n  public constructor( start: Vector3 = Vector3.zero, end: Vector3 = Vector3.zero ) {\n    this.start = start;\n    this.end = end;\n  }\n\n  /**\n   * Itself but {@link RawLine3} form.\n   */\n  public get raw(): RawLine3 {\n    return [ this.start.elements, this.end.elements ];\n  }\n\n  /**\n   * Itself but a ray.\n   */\n  public get ray(): Ray3 {\n    return Ray3.fromLine3( this );\n  }\n\n  /**\n   * A vector that represents delta of the line.\n   */\n  public delta(): Vector3 {\n    return new Vector3( line3Delta( this.raw ) );\n  }\n\n  /**\n   * Its length.\n   */\n  public length(): number {\n    return this.delta.length;\n  }\n\n  /**\n   * Return a vector that represents a certain point of the line.\n   * Same as start at t = 0, same as end at t = 1.\n   *\n   * @param t A parameter t\n   */\n  public at( t: number ): Vector3 {\n    return new Vector3( line3At( this.raw, t ) );\n  }\n\n  /**\n   * Apply given matrix4 to the line.\n   *\n   * @param matrix A matrix4 which will be applied to the line\n   */\n  public applyMatrix4( matrix: Matrix4 ): Line3 {\n    return Line3.fromRaw(\n      line3ApplyMatrix4(\n        this.raw,\n        matrix.elements,\n      )\n    );\n  }\n\n  /**\n   * Return a point that is on the line which is closest to the given point.\n   *\n   * If `segment` is true, it will treat the line as a segment which has start and end.\n   * Otherwise it will treat the line is infinite.\n   *\n   * @param point A point\n   * @param segment Is the line a segment?\n   */\n  public closestPointToPoint( point: Vector3, segment: boolean ): Vector3 {\n    return new Vector3( line3ClosestPointToPoint( this.raw, point.elements, segment ) );\n  }\n\n  /**\n   * Return a distance from the line to the given point.\n   *\n   * If `segment` is true, it will treat the line as a segment which has start and end.\n   * Otherwise it will treat the line is infinite.\n   *\n   * @param point A point\n   * @param segment Is the line a segment?\n   */\n  public distanceToPoint( point: Vector3, segment: boolean ): number {\n    return line3DistanceToPoint( this.raw, point.elements, segment );\n  }\n\n  /**\n   * Convert {@link RawLine3} to class form.\n   * @param line A {@link RawLine3}\n   */\n  public static fromRaw( line: RawLine3 ): Line3 {\n    return new Line3( new Vector3( line[ 0 ] ), new Vector3( line[ 1 ] ) );\n  }\n}\n", "import type { RawMatrix2 } from './RawMatrix2';\n\nexport function mat2Determinant( m: RawMatrix2 ): number {\n  return m[ 0 ] * m[ 3 ] - m[ 2 ] * m[ 1 ];\n}\n", "import { vecScale } from '../vec/vecScale';\nimport type { RawMatrix2 } from './RawMatrix2';\n\n/**\n * Return an inverse of given matrix.\n */\nexport function mat2Inverse( m: RawMatrix2 ): RawMatrix2 {\n  const\n    n11 = m[ 0 ], n21 = m[ 1 ],\n    n12 = m[ 2 ], n22 = m[ 3 ],\n    det = n11 * n22 - n12 * n21;\n\n  if ( det === 0.0 ) { return vecScale( m, 0.0 ); }\n\n  return vecScale( [\n    n22, -n21,\n    -n12, n11,\n  ], 1.0 / det );\n}\n", "import type { RawMatrix2 } from './RawMatrix2';\n\n/**\n * Return a multiplication result of matrices.\n */\nexport function mat2Multiply( ...mats: RawMatrix2[] ): RawMatrix2 {\n  if ( mats.length < 2 ) {\n    return mats[ 0 ];\n  }\n\n  const a = mats.shift()!;\n  const b = mat2Multiply( ...mats );\n  const\n    a00 = a[ 0 ], a01 = a[ 1 ],\n    a10 = a[ 2 ], a11 = a[ 3 ],\n    b00 = b[ 0 ], b01 = b[ 1 ],\n    b10 = b[ 2 ], b11 = b[ 3 ];\n\n  return [\n    a00 * b00 + a10 * b01,\n    a01 * b00 + a11 * b01,\n\n    a00 * b10 + a10 * b11,\n    a01 * b10 + a11 * b11,\n  ];\n}\n", "import type { RawMatrix2 } from './RawMatrix2';\n\n/**\n * Transpose a mat2.\n */\nexport function mat2Transpose(\n  source: RawMatrix2,\n): RawMatrix2 {\n  return [\n    source[ 0 ], source[ 2 ],\n    source[ 1 ], source[ 3 ],\n  ];\n}\n", "import { mat2Determinant } from './mat2Determinant';\nimport { mat2Inverse } from './mat2Inverse';\nimport { mat2Multiply } from './mat2Multiply';\nimport { mat2Transpose } from './mat2Transpose';\nimport { vecScale } from '../vec/vecScale';\nimport type { RawMatrix2 } from './RawMatrix2';\n\nconst rawIdentityMatrix2: RawMatrix2 = [\n  1.0, 0.0,\n  0.0, 1.0,\n];\n\n/**\n * A Matrix2.\n */\nexport class Matrix2 {\n  public elements: RawMatrix2;\n\n  public constructor( v: RawMatrix2 = rawIdentityMatrix2 ) {\n    this.elements = v;\n  }\n\n  /**\n   * Itself but transposed.\n   */\n  public get transpose(): Matrix2 {\n    return new Matrix2( mat2Transpose( this.elements ) );\n  }\n\n  /**\n   * Its determinant.\n   */\n  public get determinant(): number {\n    return mat2Determinant( this.elements );\n  }\n\n  /**\n   * Itself but inverted.\n   */\n  public get inverse(): Matrix2 {\n    return new Matrix2( mat2Inverse( this.elements ) );\n  }\n\n  public toString(): string {\n    const m = this.elements.map( ( v ) => v.toFixed( 3 ) );\n    return `Matrix2( ${ m[ 0 ] }, ${ m[ 2 ] }; ${ m[ 1 ] }, ${ m[ 3 ] } )`;\n  }\n\n  /**\n   * Clone this.\n   */\n  public clone(): Matrix2 {\n    return new Matrix2( this.elements.concat() as RawMatrix2 );\n  }\n\n  /**\n   * Multiply this Matrix2 by one or more Matrix2s.\n   */\n  public multiply( ...matrices: Matrix2[] ): Matrix2 {\n    return Matrix2.multiply( this, ...matrices );\n  }\n\n  /**\n   * Multiply this Matrix3 by a scalar.\n   */\n  public scaleScalar( scalar: number ): Matrix2 {\n    return new Matrix2( vecScale( this.elements, scalar ) );\n  }\n\n  /**\n   * An identity Matrix4.\n   */\n  public static get identity(): Matrix2 {\n    return new Matrix2( rawIdentityMatrix2 );\n  }\n\n  /**\n   * Multiply two or more matrices.\n   * @param matrices Matrices\n   */\n  public static multiply( ...matrices: Matrix2[] ): Matrix2 {\n    if ( matrices.length === 0 ) {\n      return Matrix2.identity;\n    } else {\n      return new Matrix2( mat2Multiply( ...matrices.map( ( m ) => m.elements ) ) );\n    }\n  }\n}\n", "import type { RawMatrix3 } from '../mat3/RawMatrix3';\nimport type { RawVector3 } from './RawVector3';\n\n/**\n * Apply a vec3 a mat3.\n */\nexport function vec3ApplyMatrix3( v: RawVector3, m: RawMatrix3 ): RawVector3 {\n  return [\n    m[ 0 ] * v[ 0 ] + m[ 3 ] * v[ 1 ] + m[ 6 ] * v[ 2 ],\n    m[ 1 ] * v[ 0 ] + m[ 4 ] * v[ 1 ] + m[ 7 ] * v[ 2 ],\n    m[ 2 ] * v[ 0 ] + m[ 5 ] * v[ 1 ] + m[ 8 ] * v[ 2 ],\n  ];\n}\n", "import { vec3ApplyMatrix3 } from '../vec3/vec3ApplyMatrix3';\nimport { vec3ApplyMatrix4 } from '../vec3/vec3ApplyMatrix4';\nimport { vecDot } from '../vec/vecDot';\nimport { vecNormalize } from '../vec/vecNormalize';\nimport { vecScale } from '../vec/vecScale';\nimport type { RawMatrix3 } from '../mat3/RawMatrix3';\nimport type { RawMatrix4 } from '../mat4/RawMatrix4';\nimport type { RawPlane3 } from './RawPlane3';\n\n/**\n * Apply given matrix4 to given plane.\n *\n * @param plane A plane\n * @param matrix A matrix4 which will be applied to the plane\n * @param normalMatrix A normalMatrix made out of {@link matrix}\n */\nexport function plane3ApplyMatrix4(\n  [ normal, distance ]: RawPlane3,\n  matrix: RawMatrix4,\n  normalMatrix: RawMatrix3,\n): RawPlane3 {\n  // normal\u306A\u3093\u3060\u304B\u3089normalMatrix\u5F53\u3066\u308C\u3070\u30E8\u30B7\uFF01\n  const newNormal = vecNormalize( vec3ApplyMatrix3( normal, normalMatrix ) );\n\n  // \u3068\u308A\u3042\u3048\u305A\u4E00\u70B9\u89B3\u6E2C\u3057\u3066\u3042\u3068\u3067dot\u53D6\u308A\u76F4\u3057\u3061\u3083\u304A\u3046\u305C\uFF01\n  const coplanar = vecScale( normal, -distance );\n  const refPoint = vec3ApplyMatrix4( coplanar, matrix );\n  const newDistance = -vecDot( refPoint, normal );\n\n  return [ newNormal, newDistance ];\n}\n", "import { vecDot } from '../vec/vecDot';\nimport type { RawPlane3 } from './RawPlane3';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Return a signed distance from given plane to the given point.\n * Make sure the `normal` is normalized.\n */\nexport function plane3DistanceToPoint(\n  [ normal, distance ]: RawPlane3,\n  point: RawVector3,\n): number {\n  return vecDot( normal, point ) + distance;\n}\n", "import { vecLength } from '../vec/vecLength';\nimport { vecScale } from '../vec/vecScale';\nimport type { RawPlane3 } from './RawPlane3';\n\n/**\n * Normalize a given plane?\n * This normalizes the normal and also divide distance by its original normal length.\n *\n * I don't come up with any use cases other than {@link planesFromProjectionMatrix}.\n *\n * @param plane The plane you want to normalize\n */\nexport function plane3Normalize( [ normal, distance ]: RawPlane3 ): RawPlane3 {\n  const invL = 1.0 / vecLength( normal );\n  return [ vecScale( normal, invL ), distance * invL ];\n}\n", "import { Matrix3 } from '../mat3/Matrix3';\nimport { Matrix4 } from '../mat4/Matrix4';\nimport { Vector3 } from '../vec3/Vector3';\nimport { plane3ApplyMatrix4 } from './plane3ApplyMatrix4';\nimport { plane3DistanceToPoint } from './plane3DistanceToPoint';\nimport { plane3Normalize } from './plane3Normalize';\nimport type { RawPlane3 } from './RawPlane3';\n\n/**\n * A 3D plane.\n */\nexport class Plane3 {\n  public normal: Vector3;\n  public distance: number;\n\n  /**\n   * Itself but {@link RawPlane3} form.\n   */\n  public get raw(): RawPlane3 {\n    return [ this.normal.elements, this.distance ];\n  }\n\n  /**\n   * Normalized plane?\n   * This normalizes the normal and also divide distance by its original normal length.\n   */\n  public get normalized(): Plane3 {\n    return Plane3.fromRaw( plane3Normalize( this.raw ) );\n  }\n\n  public constructor( normal: Vector3 = Vector3.pz, distance = 0.0 ) {\n    this.normal = normal;\n    this.distance = distance;\n  }\n\n  /**\n   * Apply given matrix4 to the plane.\n   *\n   * @param matrix A matrix4 which will be applied to the plane\n   * @param normalMatrix A normalMatrix made out of {@link matrix}. Optional\n   */\n  public applyMatrix4( matrix: Matrix4, normalMatrix?: Matrix3 ): Plane3 {\n    return Plane3.fromRaw(\n      plane3ApplyMatrix4(\n        this.raw,\n        matrix.elements,\n        normalMatrix?.elements ?? matrix.normalMatrix.elements,\n      )\n    );\n  }\n\n  /**\n   * Return a signed distance from given plane to the given point.\n   *\n   * @param point A point\n   */\n  public distanceToPoint( point: Vector3 ): number {\n    return plane3DistanceToPoint( this.raw, point.elements );\n  }\n\n  /**\n   * Convert {@link RawPlane3} to class form.\n   * @param plane A {@link RawPlane3}\n   */\n  public static fromRaw( plane: RawPlane3 ): Plane3 {\n    return new Plane3( new Vector3( plane[ 0 ] ), plane[ 1 ] );\n  }\n}\n", "import { plane3DistanceToPoint } from './plane3DistanceToPoint';\nimport type { RawPlane3 } from './RawPlane3';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Test if given point is contained in given planes or not.\n *\n * @param planes A list of planes\n * @param point A point\n */\nexport function planes3ContainPoint( planes: RawPlane3[], point: RawVector3 ): boolean {\n  return planes.every( ( plane ) => plane3DistanceToPoint( plane, point ) >= 0.0 );\n}\n", "import type { RawBox3 } from '../box3/RawBox3';\nimport type { RawPlane3 } from './RawPlane3';\n\n/**\n * Generate a set of plane3 out of a {@link RawBox3}.\n *\n * @param box A box\n */\nexport function planes3FromBox3( box: RawBox3 ): RawPlane3[] {\n  return [\n    [ [ 1.0, 0.0, 0.0 ], -box[ 0 ][ 0 ] ], // xn\n    [ [ -1.0, 0.0, 0.0 ], box[ 1 ][ 0 ] ], // xp\n    [ [ 0.0, 1.0, 0.0 ], -box[ 0 ][ 1 ] ], // yn\n    [ [ 0.0, -1.0, 0.0 ], box[ 1 ][ 1 ] ], // yp\n    [ [ 0.0, 0.0, 1.0 ], -box[ 0 ][ 2 ] ], // yn\n    [ [ 0.0, 0.0, -1.0 ], box[ 1 ][ 2 ] ], // yp\n  ];\n}\n", "import { plane3Normalize } from './plane3Normalize';\nimport type { RawMatrix4 } from '../mat4/RawMatrix4';\nimport type { RawPlane3 } from './RawPlane3';\n\n/**\n * Create frustum planes out of given projection matrix.\n *\n * @param m A projection matrix\n */\nexport function planes3FromProjectionMatrix( m: RawMatrix4 ): RawPlane3[] {\n  const\n    m11 = m[ 0 ], m12 = m[ 4 ], m13 = m[ 8 ], m14 = m[ 12 ],\n    m21 = m[ 1 ], m22 = m[ 5 ], m23 = m[ 9 ], m24 = m[ 13 ],\n    m31 = m[ 2 ], m32 = m[ 6 ], m33 = m[ 10 ], m34 = m[ 14 ],\n    m41 = m[ 3 ], m42 = m[ 7 ], m43 = m[ 11 ], m44 = m[ 15 ];\n\n  return [\n    plane3Normalize( [ [ m41 - m11, m42 - m12, m43 - m13 ], m44 - m14 ] ), // xp\n    plane3Normalize( [ [ m41 + m11, m42 + m12, m43 + m13 ], m44 + m14 ] ), // xn\n    plane3Normalize( [ [ m41 - m21, m42 - m22, m43 - m23 ], m44 - m24 ] ), // yp\n    plane3Normalize( [ [ m41 + m21, m42 + m22, m43 + m23 ], m44 + m24 ] ), // yn\n    plane3Normalize( [ [ m41 - m31, m42 - m32, m43 - m33 ], m44 - m34 ] ), // zn\n    plane3Normalize( [ [ m41 + m31, m42 + m32, m43 + m33 ], m44 + m34 ] ), // zp\n  ];\n}\n", "import { plane3DistanceToPoint } from './plane3DistanceToPoint';\nimport type { RawBox3 } from '../box3/RawBox3';\nimport type { RawPlane3 } from './RawPlane3';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Test if given box intersects with planes or not.\n *\n * @param planes A list of planes\n * @param box A box3\n */\nexport function planes3IntersectBox3( planes: RawPlane3[], box: RawBox3 ): boolean {\n  return planes.every( ( plane ) => {\n    const v = plane[ 0 ].map( ( nc, i ) => box[ nc > 0.0 ? 1 : 0 ][ i ] ) as RawVector3;\n    return plane3DistanceToPoint( plane, v ) >= 0.0;\n  } );\n}\n", "import { RawSphere3 } from '../sphere3/RawSphere3';\nimport { plane3DistanceToPoint } from './plane3DistanceToPoint';\nimport type { RawPlane3 } from './RawPlane3';\n\n/**\n * Test if given sphere intersects with planes or not.\n *\n * It does not do strict intersection test but still should work well with frustum cull use cases.\n * See the test case for more details.\n *\n * @param planes A list of planes\n * @param sphere A sphere3\n */\nexport function planes3IntersectSphere3( planes: RawPlane3[], sphere: RawSphere3 ): boolean {\n  return planes.every( ( plane ) => (\n    plane3DistanceToPoint( plane, sphere[ 0 ] ) >= -sphere[ 1 ]\n  ) );\n}\n", "import { Box3 } from '../box3/Box3';\nimport { Matrix4 } from '../mat4/Matrix4';\nimport { Plane3 } from './Plane3';\nimport { Sphere3 } from '../sphere3/Sphere3';\nimport { Vector3 } from '../vec3/Vector3';\nimport { planes3ContainPoint } from './planes3ContainPoint';\nimport { planes3FromBox3 } from './planes3FromBox3';\nimport { planes3FromProjectionMatrix } from './planes3FromProjectionMatrix';\nimport { planes3IntersectBox3 } from './planes3IntersectBox3';\nimport { planes3IntersectSphere3 } from './planes3IntersectSphere3';\nimport type { RawPlane3 } from './RawPlane3';\n\n/**\n * A set of {@link Plane3}.\n */\nexport class Planes3 {\n  public planes: Plane3[];\n\n  /**\n   * Itself but {@link RawPlane3}[] form.\n   */\n  public get raw(): RawPlane3[] {\n    return this.planes.map( ( plane ) => plane.raw );\n  }\n\n  public constructor( planes: Plane3[] ) {\n    this.planes = planes;\n  }\n\n  /**\n   * Test if given point is contained in the planes or not.\n   *\n   * @param point A point\n   */\n  public containPoint( point: Vector3 ): boolean {\n    return planes3ContainPoint( this.raw, point.elements );\n  }\n\n  /**\n   * Test if given box intersects with the planes or not.\n   *\n   * @param box A box3\n   */\n  public intersectBox3( box: Box3 ): boolean {\n    return planes3IntersectBox3( this.raw, box.raw );\n  }\n\n  /**\n   * Test if given sphere intersects with the planes or not.\n   *\n   * It does not do strict intersection test but still should work well with frustum cull use cases.\n   * See the test case for more details.\n   *\n   * @param sphere A sphere3\n   */\n  public intersectSphere3( sphere: Sphere3 ): boolean {\n    return planes3IntersectSphere3( this.raw, sphere.raw );\n  }\n\n  /**\n   * Convert {@link RawPlane3}[] to class form.\n   *\n   * @param planes A {@link RawPlane3}[]\n   */\n  public static fromRaw( planes: RawPlane3[] ): Planes3 {\n    return new Planes3( planes.map( ( plane ) => Plane3.fromRaw( plane ) ) );\n  }\n\n  /**\n   * Generate a set of plane3 out of a {@link RawBox3}.\n   *\n   * @param box A box\n   */\n  public static fromBox3( box: Box3 ): Planes3 {\n    return Planes3.fromRaw( planes3FromBox3( box.raw ) );\n  }\n\n  /**\n   * Create frustum planes out of given projection matrix.\n   *\n   * @param matrix A projection matrix\n   */\n  public static fromProjectionMatrix( matrix: Matrix4 ): Planes3 {\n    return Planes3.fromRaw( planes3FromProjectionMatrix( matrix.elements ) );\n  }\n}\n", "import { vecLengthSq } from '../vec/vecLengthSq';\nimport { vecSub } from '../vec/vecSub';\nimport type { RawSphere3 } from './RawSphere3';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Test if given point is contained in given sphere or not.\n * @param sphere A sphere\n * @param point A point\n */\nexport function sphere3ContainsPoint( sphere: RawSphere3, point: RawVector3 ): boolean {\n  return vecLengthSq( vecSub( sphere[ 0 ], point ) ) <= sphere[ 1 ] * sphere[ 1 ];\n}\n", "import { Vector3 } from '../vec3/Vector3';\nimport { sphere3ContainsPoint } from './sphere3ContainsPoint';\nimport type { RawSphere3 } from './RawSphere3';\n\n/**\n * A 3D sphere.\n */\nexport class Sphere3 {\n  public origin: Vector3;\n  public radius: number;\n\n  public constructor( origin: Vector3 = Vector3.zero, radius: number = 0.0 ) {\n    this.origin = origin;\n    this.radius = radius;\n  }\n\n  /**\n   * Itself but {@link RawSphere3} form.\n   */\n  public get raw(): RawSphere3 {\n    return [ this.origin.elements, this.radius ];\n  }\n\n  /**\n   * Test if given point is contained in the sphere or not.\n   *\n   * @param point A point\n   */\n  public containsPoint( point: Vector3 ): boolean {\n    return sphere3ContainsPoint( this.raw, point.elements );\n  }\n\n  /**\n   * Convert {@link RawSphere3} to class form.\n   * @param sphere A {@link RawSphere3}\n   */\n  public static fromRaw( sphere: RawSphere3 ): Sphere3 {\n    return new Sphere3( new Vector3( sphere[ 0 ] ), sphere[ 1 ] );\n  }\n}\n", "import { vec3ApplyMatrix3 } from '../vec3/vec3ApplyMatrix3';\nimport type { RawMatrix3 } from '../mat3/RawMatrix3';\nimport type { RawVector3 } from '../vec3/RawVector3';\nimport type { RawVector4 } from './RawVector4';\n\n/**\n * Apply a vec4 a mat3 (with an implicit 1 on m44).\n */\nexport function vec4ApplyMatrix3( v: RawVector4, m: RawMatrix3 ): RawVector4 {\n  const v3: RawVector3 = [ v[ 0 ], v[ 1 ], v[ 2 ] ];\n  const xyz = vec3ApplyMatrix3( v3, m );\n  const w = v[ 3 ];\n  return [ xyz[ 0 ], xyz[ 1 ], xyz[ 2 ], w ];\n}\n", "import { Matrix4 } from '../mat4/Matrix4';\nimport { Vector } from '../vec/Vector';\nimport { vec4ApplyMatrix3 } from './vec4ApplyMatrix3';\nimport { vec4ApplyMatrix4 } from './vec4ApplyMatrix4';\nimport type { Matrix3 } from '../mat3/Matrix3';\nimport type { RawVector4 } from './RawVector4';\n\n/**\n * A Vector3.\n */\nexport class Vector4 extends Vector<Vector4> {\n  public elements: RawVector4;\n\n  public constructor( v: RawVector4 = [ 0.0, 0.0, 0.0, 0.0 ] ) {\n    super();\n    this.elements = v;\n  }\n\n  /**\n   * An x component of this.\n   */\n  public get x(): number {\n    return this.elements[ 0 ];\n  }\n\n  public set x( x: number ) {\n    this.elements[ 0 ] = x;\n  }\n\n  /**\n   * A y component of this.\n   */\n  public get y(): number {\n    return this.elements[ 1 ];\n  }\n\n  public set y( y: number ) {\n    this.elements[ 1 ] = y;\n  }\n\n  /**\n   * A z component of this.\n   */\n  public get z(): number {\n    return this.elements[ 2 ];\n  }\n\n  public set z( z: number ) {\n    this.elements[ 2 ] = z;\n  }\n\n  /**\n   * A w component of this.\n   */\n  public get w(): number {\n    return this.elements[ 3 ];\n  }\n\n  public set w( z: number ) {\n    this.elements[ 3 ] = z;\n  }\n\n  public toString(): string {\n    return `Vector4( ${ this.x.toFixed( 3 ) }, ${ this.y.toFixed( 3 ) }, ${ this.z.toFixed( 3 ) }, ${ this.w.toFixed( 3 ) } )`;\n  }\n\n  /**\n   * Apply this vector a mat3 (with an implicit 1 on m44).\n   */\n  public applyMatrix3( matrix: Matrix3 ): Vector4 {\n    return new Vector4( vec4ApplyMatrix3( this.elements, matrix.elements ) );\n  }\n\n  /**\n   * Multiply this vector by a mat4.\n   */\n  public applyMatrix4( matrix: Matrix4 ): Vector4 {\n    return new Vector4( vec4ApplyMatrix4( this.elements, matrix.elements ) );\n  }\n\n  protected __new( v: RawVector4 ): Vector4 {\n    return new Vector4( v );\n  }\n\n  /**\n   * Vector4( 0.0, 0.0, 0.0, 0.0 )\n   */\n  public static get zero(): Vector4 {\n    return new Vector4( [ 0.0, 0.0, 0.0, 0.0 ] );\n  }\n\n  /**\n   * Vector4( 1.0, 1.0, 1.0, 1.0 )\n   */\n  public static get one(): Vector4 {\n    return new Vector4( [ 1.0, 1.0, 1.0, 1.0 ] );\n  }\n}\n", "import { MidiParseResult, MidiParseResultHeader, MidiParseResultTrack } from './MidiParseResult';\nimport { arraySerial } from '../array/arraySerial';\n\nfunction readU8( array: Uint8Array, headBox: [ number ] ): number {\n  return array[ headBox[ 0 ] ++ ];\n}\n\n/**\n * Big endian\n */\nfunction readU16( array: Uint8Array, headBox: [ number ] ): number {\n  return readU8( array, headBox ) * 256 + readU8( array, headBox );\n}\n\n/**\n * Big endian\n */\nfunction readU32( array: Uint8Array, headBox: [ number ] ): number {\n  return readU16( array, headBox ) * 65536 + readU16( array, headBox );\n}\n\nfunction readUVar( array: Uint8Array, headBox: [ number ] ): number {\n  let v = 0;\n  for ( ;; ) {\n    const vv = readU8( array, headBox );\n    v = v * 128 + ( vv & 127 );\n\n    if ( vv < 128 ) {\n      return v;\n    }\n  }\n}\n\nfunction parseHeader( array: Uint8Array, headBox: [ number ] ): MidiParseResultHeader {\n  // skip type and length (4+4)\n  // length has to be 6, there's no need to parse\n  headBox[ 0 ] += 8;\n\n  return [\n    readU16( array, headBox ),\n    readU16( array, headBox ),\n    readU16( array, headBox ),\n  ];\n}\n\nfunction parseTrack( array: Uint8Array, headBox: [ number ] ): MidiParseResultTrack {\n  // skip type (4)\n  headBox[ 0 ] += 4;\n\n  const endOfTrack = headBox[ 0 ] + readU32( array, headBox ) + 4;\n\n  const track: MidiParseResultTrack = [];\n  let type = 0;\n\n  while ( headBox[ 0 ] < endOfTrack ) {\n    const delta = readUVar( array, headBox );\n    const status = readU8( array, headBox );\n    type = status < 128 ? type : status;\n    const data0 = status < 128 ? status : readU8( array, headBox );\n\n    if ( type < 0xc0 ) {\n      // note on (9x), note off (8x), polyphonic key pressure (Ax), control change (Bx)\n\n      track.push( [\n        delta,\n        type,\n        data0, // note or cc number\n        readU8( array, headBox ), // velocity, pressure, or data\n      ] );\n    } else if ( type === 0xff ) {\n      // meta events\n\n      const eventLength = readU8( array, headBox );\n\n      track.push( [\n        delta,\n        type,\n        data0,\n        arraySerial( eventLength ).map( () => readU8( array, headBox ) ),\n      ] );\n\n      if ( data0 === 0x2f ) { // end of track\n        break;\n      }\n    } else {\n      throw new Error( `${ type }` );\n    }\n  }\n\n  return track;\n}\n\nexport function midiParse( buffer: ArrayBuffer ): MidiParseResult {\n  const array = new Uint8Array( buffer );\n  const headBox: [ number ] = [ 0 ];\n\n  const header = parseHeader( array, headBox );\n  const tracks: MidiParseResultTrack[] = [];\n\n  while ( headBox[ 0 ] < array.length ) {\n    tracks.push( parseTrack( array, headBox ) );\n  }\n\n  return [ header, tracks ];\n}\n", "import type { PokerRank } from './PokerRank';\n\nexport const pokerRanksByStrength: PokerRank[] = [\n  '2',\n  '3',\n  '4',\n  '5',\n  '6',\n  '7',\n  '8',\n  '9',\n  'T',\n  'J',\n  'Q',\n  'K',\n  'A',\n];\n", "import type { PokerSuit } from './PokerSuit';\n\nexport const pokerSuitsByIndex: PokerSuit[] = [\n  'c',\n  'd',\n  'h',\n  's',\n];\n", "import { pokerRanksByStrength } from './pokerRanksByStrength';\nimport { pokerSuitsByIndex } from './pokerSuitsByIndex';\nimport type { PokerCard } from './PokerCard';\n\n/**\n * Create a 52-card deck.\n * You might want to use {@link shuffleArray} to shuffle the deck.\n */\nexport function createPokerDeck(): PokerCard[] {\n  const array: PokerCard[] = [];\n\n  pokerSuitsByIndex.map( ( suit ) => (\n    pokerRanksByStrength.map( ( rank ) => (\n      array.push( rank + suit as PokerCard )\n    ) )\n  ) );\n\n  return array;\n}\n", "import { PokerHand } from './PokerHand';\n\nexport const pokerHandStrengthMap: { [ hand in PokerHand ]: number } = {\n  'HighCard': 0,\n  'OnePair': 1,\n  'TwoPair': 2,\n  'ThreeOfAKind': 3,\n  'Straight': 4,\n  'Flush': 5,\n  'FullHouse': 6,\n  'FourOfAKind': 7,\n  'StraightFlush': 8,\n};\n", "import type { PokerRank } from './PokerRank';\n\nexport const pokerRankStrengthMap: { [ rank in PokerRank ]: number } = {\n  '2': 0,\n  '3': 1,\n  '4': 2,\n  '5': 3,\n  '6': 4,\n  '7': 5,\n  '8': 6,\n  '9': 7,\n  'T': 8,\n  'J': 9,\n  'Q': 10,\n  'K': 11,\n  'A': 12\n};\n", "import type { PokerSuit } from './PokerSuit';\n\nexport const pokerSuitIndexMap: { [ suit in PokerSuit ]: number } = {\n  'c': 0,\n  'd': 1,\n  'h': 2,\n  's': 3,\n};\n", "import { pokerRankStrengthMap } from './pokerRankStrengthMap';\nimport { pokerSuitIndexMap } from './pokerSuitIndexMap';\nimport type { PokerCard } from './PokerCard';\nimport type { PokerRank } from './PokerRank';\nimport type { PokerSuit } from './PokerSuit';\n\n/**\n * Sort given array of cards in place by rank (and suit).\n */\nexport function sortPokerCardsByRank( cards: PokerCard[] ): PokerCard[] {\n  return cards\n    .sort( ( a, b ) => (\n      pokerSuitIndexMap[ a[ 1 ] as PokerSuit ] - pokerSuitIndexMap[ b[ 1 ] as PokerSuit ]\n    ) )\n    .sort( ( a, b ) => (\n      pokerRankStrengthMap[ a[ 0 ] as PokerRank ] - pokerRankStrengthMap[ b[ 0 ] as PokerRank ]\n    ) );\n}\n", "import { MapOfSet } from '../MapOfSet/MapOfSet';\nimport { pokerHandStrengthMap } from './pokerHandStrengthMap';\nimport { pokerRankStrengthMap } from './pokerRankStrengthMap';\nimport { pokerRanksByStrength } from './pokerRanksByStrength';\nimport { sortPokerCardsByRank } from './sortPokerCardsByRank';\nimport type { PokerCard } from './PokerCard';\nimport type { PokerHand } from './PokerHand';\nimport type { PokerRank } from './PokerRank';\nimport type { PokerSuit } from './PokerSuit';\n\nexport interface EvaluatePokerHandResult {\n  hand: PokerHand;\n  strength: number[];\n  cards: [ PokerCard, PokerCard, PokerCard, PokerCard, PokerCard ];\n}\n\nexport function evaluatePokerHand( cards: PokerCard[] ): EvaluatePokerHandResult {\n  // cards mutable edition\n  const cards_ = cards.concat();\n\n  const cardsByRank = new MapOfSet<PokerRank, PokerCard>();\n  const cardsBySuit = new MapOfSet<PokerSuit, PokerCard>();\n\n  cards_.map( ( card ) => {\n    const rank = card[ 0 ] as PokerRank;\n    const suit = card[ 1 ] as PokerSuit;\n    cardsByRank.add( rank, card );\n    cardsBySuit.add( suit, card );\n  } );\n\n  // pairs\n  const fours: PokerRank[] = [];\n  const threes: PokerRank[] = [];\n  const twos: PokerRank[] = [];\n\n  pokerRanksByStrength.map( ( rank ) => {\n    const cards = cardsByRank.get( rank );\n    if ( cards.size > 3 ) {\n      fours.push( rank );\n    } else if ( cards.size > 2 ) {\n      threes.push( rank );\n    } else if ( cards.size > 1 ) {\n      twos.push( rank );\n    }\n  } );\n\n  // straight\n  let straightCards: PokerCard[] | undefined;\n  {\n    let current: PokerCard[] = [];\n\n    // handle steel wheel\n    const a = Array.from( cardsByRank.get( 'A' ) )[ 0 ];\n    if ( a ) {\n      current.push( a );\n    }\n\n    pokerRanksByStrength.map( ( rank ) => {\n      const card = Array.from( cardsByRank.get( rank ) )[ 0 ];\n      if ( card ) {\n        current.push( card );\n\n        if ( current.length > 4 ) {\n          straightCards = current;\n        }\n      } else {\n        current = [];\n      }\n    } );\n  }\n\n  // straight flush\n  if ( straightCards ) {\n    for ( const [ suit, cardsSet ] of cardsBySuit.map ) {\n      if ( cardsSet.size > 0 ) {\n        let straightFlushCards: PokerCard[] | undefined;\n        let current: PokerCard[] = [];\n\n        // handle steel wheel\n        const target = 'A' + suit as PokerCard;\n        const a = cardsSet.has( target );\n        if ( a ) {\n          current.push( target );\n        }\n\n        pokerRanksByStrength.map( ( rank ) => {\n          const target = rank + suit as PokerCard;\n          if ( cardsSet.has( target ) ) {\n            current.push( target );\n\n            if ( current.length > 4 ) {\n              straightFlushCards = current;\n            }\n          } else {\n            current = [];\n          }\n        } );\n\n        if ( straightFlushCards ) {\n          straightFlushCards.splice( 0, straightFlushCards.length - 5 );\n\n          const hand = 'StraightFlush';\n          const strength = [\n            pokerHandStrengthMap[ hand ],\n            pokerRankStrengthMap[ straightFlushCards[ 4 ][ 0 ] as PokerRank ],\n          ];\n\n          return {\n            hand,\n            cards: straightFlushCards as [ PokerCard, PokerCard, PokerCard, PokerCard, PokerCard ],\n            strength,\n          };\n        }\n      }\n    }\n  }\n\n  // four of a kind\n  if ( fours.length > 0 ) {\n    fours.sort( ( a, b ) => pokerRankStrengthMap[ a ] - pokerRankStrengthMap[ b ] );\n    fours.splice( 0, fours.length - 1 );\n\n    // 5s, 5c, Kd, 6d, 9c, 5d, 5h\n\n    const sameCards = Array.from( cardsByRank.get( fours[ 0 ] ) );\n    sameCards.map( ( card ) => (\n      cards_.splice( cards_.indexOf( card ), 1 )\n    ) );\n    // Kd, 6d, 9c\n\n    sortPokerCardsByRank( cards_ ).splice( 0, cards_.length - 1 );\n    // Kd\n\n    const hand = 'FourOfAKind';\n    const strength = [\n      pokerHandStrengthMap[ hand ],\n      pokerRankStrengthMap[ fours[ 0 ] ],\n      pokerRankStrengthMap[ cards_[ 0 ][ 0 ] as PokerRank ],\n    ];\n\n    cards_.push( ...sameCards );\n    sortPokerCardsByRank( cards_ );\n    // 5c, 5d, 5h, 5s, Kd\n\n    return {\n      hand,\n      cards: cards_ as [ PokerCard, PokerCard, PokerCard, PokerCard, PokerCard ],\n      strength,\n    };\n  }\n\n  // full house\n  if ( threes.length > 0 && threes.length + twos.length > 1 ) {\n    threes.sort( ( a, b ) => pokerRankStrengthMap[ a ] - pokerRankStrengthMap[ b ] );\n\n    // tricky part: it is possible to have two or more threes at once\n    // just transfer threes which is not highest\n    // and wish we'll do this right in the rest of the code\n    twos.push( ...threes.splice( 0, threes.length - 1 ) );\n\n    twos.sort( ( a, b ) => pokerRankStrengthMap[ a ] - pokerRankStrengthMap[ b ] );\n    twos.splice( 0, twos.length - 1 );\n\n    // 7d, 7s, Tc, Td, 7h, 9d, Th\n\n    const sameCards = Array.from( cardsByRank.get( threes[ 0 ] ) );\n    sameCards.push( ...Array.from( cardsByRank.get( twos[ 0 ] ) ) );\n    // sameCards: Tc, Td, Th, 7d, 7s, 7h\n\n    sortPokerCardsByRank( sameCards ).splice( 0, sameCards.length - 5 );\n    // sameCards: 7h, 7s, Tc, Td, Th\n\n    const hand = 'FullHouse';\n    const strength = [\n      pokerHandStrengthMap[ hand ],\n      pokerRankStrengthMap[ threes[ 0 ] ],\n      pokerRankStrengthMap[ twos[ 0 ] ],\n    ];\n\n    return {\n      hand,\n      cards: sameCards as [ PokerCard, PokerCard, PokerCard, PokerCard, PokerCard ],\n      strength,\n    };\n  }\n\n  // flush\n  for ( const [ _suit, cardsSet ] of cardsBySuit.map ) {\n    if ( cardsSet.size > 4 ) {\n      const cards = sortPokerCardsByRank( Array.from( cardsSet ) );\n      cards.splice( 0, cards.length - 5 );\n\n      const hand = 'Flush';\n      const strength = [\n        pokerHandStrengthMap[ hand ],\n        ...cards\n          .concat()\n          .reverse()\n          .map( ( card ) => (\n            pokerRankStrengthMap[ card[ 0 ] as PokerRank ]\n          ) ),\n      ];\n\n      return {\n        hand,\n        cards: cards as [ PokerCard, PokerCard, PokerCard, PokerCard, PokerCard ],\n        strength,\n      };\n    }\n  }\n\n  // straight\n  if ( straightCards ) {\n    straightCards.splice( 0, straightCards.length - 5 );\n\n    const hand = 'Straight';\n    const strength = [\n      pokerHandStrengthMap[ hand ],\n      pokerRankStrengthMap[ straightCards[ 4 ][ 0 ] as PokerRank ],\n    ];\n\n    return {\n      hand,\n      cards: straightCards as [ PokerCard, PokerCard, PokerCard, PokerCard, PokerCard ],\n      strength,\n    };\n  }\n\n  // three of a kind\n  if ( threes.length > 0 ) {\n    threes.sort( ( a, b ) => pokerRankStrengthMap[ a ] - pokerRankStrengthMap[ b ] );\n    threes.splice( 0, threes.length - 1 );\n\n    // Ah, Ad, Kc, 7s, 4s, Qc, As\n\n    const sameCards = Array.from( cardsByRank.get( threes[ 0 ] ) );\n    sameCards.map( ( card ) => (\n      cards_.splice( cards_.indexOf( card ), 1 )\n    ) );\n    // Kc, 7s, 4s, Qc\n\n    sortPokerCardsByRank( cards_ ).splice( 0, cards_.length - 2 );\n    // Qc, Kc\n\n    const hand = 'ThreeOfAKind';\n    const strength = [\n      pokerHandStrengthMap[ hand ],\n      pokerRankStrengthMap[ threes[ 0 ] ],\n      pokerRankStrengthMap[ cards_[ 1 ][ 0 ] as PokerRank ],\n      pokerRankStrengthMap[ cards_[ 0 ][ 0 ] as PokerRank ],\n    ];\n\n    cards_.push( ...sameCards );\n    sortPokerCardsByRank( cards_ );\n    // Qc, Kc, Ad, Ah, As\n\n    return {\n      hand,\n      cards: cards_ as [ PokerCard, PokerCard, PokerCard, PokerCard, PokerCard ],\n      strength,\n    };\n  }\n\n  // two pair\n  if ( twos.length > 1 ) {\n    twos.sort( ( a, b ) => pokerRankStrengthMap[ a ] - pokerRankStrengthMap[ b ] );\n    twos.splice( 0, twos.length - 2 );\n\n    // 4c, 8d, 7h, 4h, 8h, Jc, 2s\n\n    const pairs = Array.from( cardsByRank.get( twos[ 0 ] ) );\n    pairs.push( ...Array.from( cardsByRank.get( twos[ 1 ] ) ) );\n    pairs.map( ( card ) => (\n      cards_.splice( cards_.indexOf( card ), 1 )\n    ) );\n    // 7h, Jc, 2s\n\n    sortPokerCardsByRank( cards_ ).splice( 0, cards_.length - 1 );\n    // Jc\n\n    const hand = 'TwoPair';\n    const strength = [\n      pokerHandStrengthMap[ hand ],\n      pokerRankStrengthMap[ twos[ 1 ] ],\n      pokerRankStrengthMap[ twos[ 0 ] ],\n      pokerRankStrengthMap[ cards_[ 0 ][ 0 ] as PokerRank ],\n    ];\n\n    cards_.push( ...pairs );\n    sortPokerCardsByRank( cards_ );\n    // 4c, 4h, 8d, 8h, Jc\n\n    return {\n      hand,\n      cards: cards_ as [ PokerCard, PokerCard, PokerCard, PokerCard, PokerCard ],\n      strength,\n    };\n  }\n\n  // one pair\n  if ( twos.length > 0 ) {\n    // 3c, 5d, 8c, 8s, Ac, Qd, 7h\n\n    const pair = Array.from( cardsByRank.get( twos[ 0 ] ) );\n    pair.map( ( card ) => (\n      cards_.splice( cards_.indexOf( card ), 1 )\n    ) );\n    // 3c, 5d, Ac, Qd, 7h\n\n    sortPokerCardsByRank( cards_ ).splice( 0, cards_.length - 3 );\n    // 7h, Qd, Ac\n\n    const hand = 'OnePair';\n    const strength = [\n      pokerHandStrengthMap[ hand ],\n      pokerRankStrengthMap[ twos[ 0 ] ],\n      pokerRankStrengthMap[ cards_[ 2 ][ 0 ] as PokerRank ],\n      pokerRankStrengthMap[ cards_[ 1 ][ 0 ] as PokerRank ],\n      pokerRankStrengthMap[ cards_[ 0 ][ 0 ] as PokerRank ],\n    ];\n\n    cards_.push( ...pair );\n    sortPokerCardsByRank( cards_ );\n    // 7h, 8c, 8s, Qd, Ac\n\n    return {\n      hand,\n      cards: cards_ as [ PokerCard, PokerCard, PokerCard, PokerCard, PokerCard ],\n      strength,\n    };\n  }\n\n  // high card\n  {\n    const hand = 'HighCard';\n\n    // 2h, 5c, 6c, 7s, Td, Ad, Kd\n\n    sortPokerCardsByRank( cards_ );\n    // 2h, 5c, 6c, 7s, Td, Kd, Ad\n\n    cards_.splice( 0, cards_.length - 5 );\n    // 6c, 7s, Td, Kd, Ad\n\n    const strength = [\n      pokerHandStrengthMap[ hand ],\n      pokerRankStrengthMap[ cards_[ 4 ][ 0 ] as PokerRank ],\n      pokerRankStrengthMap[ cards_[ 3 ][ 0 ] as PokerRank ],\n      pokerRankStrengthMap[ cards_[ 2 ][ 0 ] as PokerRank ],\n      pokerRankStrengthMap[ cards_[ 1 ][ 0 ] as PokerRank ],\n      pokerRankStrengthMap[ cards_[ 0 ][ 0 ] as PokerRank ],\n    ];\n\n    return {\n      hand,\n      cards: cards_ as [ PokerCard, PokerCard, PokerCard, PokerCard, PokerCard ],\n      strength,\n    };\n  }\n}\n", "import type { PokerHand } from './PokerHand';\n\nexport const pokerHandsByStrength: PokerHand[] = [\n  'HighCard',\n  'OnePair',\n  'TwoPair',\n  'ThreeOfAKind',\n  'Straight',\n  'Flush',\n  'FullHouse',\n  'FourOfAKind',\n  'StraightFlush',\n];\n", "/**\n * Retry given function for n times.\n *\n * See also: {@link retry}\n */\nexport async function asyncRetry<T>( func: () => Promise<T>, n: number ): Promise<T> {\n  return await func().catch( ( error ) => {\n    if ( n <= 1 ) {\n      throw error;\n    }\n\n    return asyncRetry( func, n - 1 );\n  } );\n}\n", "/**\n * Retry given function for n times.\n *\n * See also: {@link asyncRetry}\n */\nexport function retry<T>( func: () => T, n: number ): T {\n  try {\n    return func();\n  } catch ( error ) {\n    if ( n <= 1 ) {\n      throw error;\n    }\n\n    return retry( func, n - 1 );\n  }\n}\n", "import { STNICCCFrame } from './STNICCCFrame';\n\n/**\n * Ref: http://arsantica-online.com/st-niccc-competition/\n *\n * @param buffer The input ST-NICCC data\n */\nexport function parseSTNICCC( buffer: ArrayBuffer ): STNICCCFrame[] {\n  const frames: STNICCCFrame[] = [];\n\n  const array = new Uint8Array( buffer );\n\n  const palette = new Uint16Array( 16 );\n\n  let head = 0;\n\n  // when poly-descriptor says 0xfe\n  let shouldSkip = false;\n\n  // when poly-descriptor says 0xfd\n  let shouldEnd = false;\n\n  // > Every frame stores the following data:\n  for ( ;; ) {\n    // > 1 byte Flags Bit 0: Frame needs to clear the screen.\n    // > Bit 1: Frame contains palette data.\n    // > Bit 2: Frame is stored in indexed mode.\n    const flags = array[ head ++ ];\n    const needsClear = ( flags & 1 ) === 1;\n    const hasPalette = ( flags >> 1 & 1 ) === 1;\n    const indexedMode = ( flags >> 2 & 1 ) === 1;\n\n    // > If frame contains palette data\n    if ( hasPalette ) {\n      // > 1 word Bitmask\n      const bitmask = array[ head ++ ] << 8 | array[ head ++ ];\n\n      // > For every set bit in the Bitmask (0-15)\n      for ( let i = 0; i < 16; i ++ ) {\n        if ( bitmask >> ( 15 - i ) & 1 ) {\n          // > 1 word Color The color has to be copied into the palette at the reverse index of the actual bit,\n          // > because the bitmask is stored in reverse order.\n          // > In other words: If bit 15 of mask is set -> update color 0 of palette,\n          // > \u2026\n          // > if bit 0 of mask is set -> update color 15 of palette.\n\n          palette[ i ] = array[ head ++ ] << 8 | array[ head ++ ];\n        }\n      }\n    }\n\n    // > If frame is stored in indexed mode\n    if ( indexedMode ) {\n      // > 1 byte Number of vertices (0-255)\n      const nVertices = array[ head ++ ];\n\n      // > For every Vertex\n      // > {\n      // > 1 byte X-position\n      // > 1 byte Y-position\n      // > }\n      const vertices = array.subarray( head, head + 2 * nVertices );\n      head += 2 * nVertices;\n\n      const polygons: { colorIndex: number; indices: number[] }[] = [];\n\n      // > While (\u2026)\n      for ( ;; ) {\n        // > 1 byte Poly-descriptor Contains: hi-nibble - 4 bits color-index\n        // > lo-nibble - 4 bits number of polygon vertices\n        // >\n        // > Some special cases are encoded in the descriptor byte:\n        // > $ff = End of frame\n        // > $fe = End of frame and the stream skips to the next 64KB block\n        // > $fd = End of stream (we are done \\o/)\n        const descriptor = array[ head ++ ];\n\n        if ( descriptor === 0xff ) { // end of frame\n          break;\n\n        } else if ( descriptor === 0xfe ) { // end of frame + skip to the next 64KB\n          shouldSkip = true;\n          break;\n\n        } else if ( descriptor === 0xfd ) { // end of stream\n          shouldEnd = true;\n          break;\n\n        }\n\n        const colorIndex = descriptor >> 4 & 15;\n        const nIndices = descriptor & 15;\n\n        // > For every vertex of the polygon\n        // > {\n        // > 1 byte Vertex-id (0-255)\n        // > }\n        const indices = array.subarray( head, head + nIndices );\n        head += nIndices;\n\n        polygons.push( {\n          colorIndex,\n          indices: Array.from( indices ),\n        } );\n      }\n\n      frames.push( {\n        needsClear,\n        indexedMode,\n        palette: Array.from( palette ),\n        vertices: Array.from( vertices ),\n        polygons,\n      } );\n\n    // > Else if frame is stored in non-indexed mode\n    } else {\n      const polygons: { colorIndex: number; vertices: number[] }[] = [];\n\n      // > While (\u2026)\n      for ( ;; ) {\n        // > 1 byte Poly-descriptor (See indexed mode)\n        const descriptor = array[ head ++ ];\n\n        if ( descriptor === 0xff ) { // end of frame\n          break;\n\n        } else if ( descriptor === 0xfe ) { // end of frame + skip to the next 64KB\n          shouldSkip = true;\n          break;\n\n        } else if ( descriptor === 0xfd ) { // end of stream\n          shouldEnd = true;\n          break;\n\n        }\n\n        const colorIndex = descriptor >> 4 & 15;\n        const nVertices = descriptor & 15;\n\n        // > For every vertex of the polygon\n        // > {\n        // > 1 byte Vertex-id (0-255)\n        // > }\n        const vertices = array.subarray( head, head + 2 * nVertices );\n        head += 2 * nVertices;\n\n        polygons.push( {\n          colorIndex,\n          vertices: Array.from( vertices ),\n        } );\n      }\n\n      frames.push( {\n        needsClear,\n        indexedMode,\n        palette: Array.from( palette ),\n        polygons,\n      } );\n    }\n\n    if ( shouldSkip ) {\n      head = ( Math.floor( head / 0x10000 ) + 1 ) * 0x10000;\n      shouldSkip = false;\n    }\n\n    if ( shouldEnd ) {\n      break;\n    }\n  }\n\n  return frames;\n}\n", "import { STNICCCFrame } from './STNICCCFrame';\nimport { colorFromAtariST } from '../color/colorFromAtariST';\nimport { colorToHex } from '../color/colorToHex';\n\nexport function stnicccToSVG( frames: STNICCCFrame[], options: {\n  fps?: number;\n} = {} ): string {\n  const delta = 1.0 / ( options?.fps ?? 30.0 );\n\n  let svg = '<svg width=\"256\" height=\"200\" viewBox=\"0 0 256 200\" xmlns=\"http://www.w3.org/2000/svg\">';\n\n  let style = `g{visibility:hidden;animation-duration:${ ( delta * frames.length ).toFixed( 3 ) }s;animation-iteration-count:infinite;animation-name:frame}@keyframes frame{0%{visibility:visible}${ 200.0 / frames.length }%{visibility:hidden}}`;\n\n  frames.map( ( frame, iFrame ) => {\n    const { indexedMode, palette, polygons } = frame;\n\n    style += `#f${ iFrame }{animation-delay:${ ( delta * iFrame ).toFixed( 3 ) }s}`;\n\n    const paletteInHex = palette.map( ( stColor ) => {\n      const color = colorFromAtariST( stColor );\n      return colorToHex( color );\n    } );\n\n    let childrenStr = '<rect width=\"256\" height=\"200\" fill=\"#000\" />';\n\n    let currentColorIndex = -1;\n    let d = '';\n\n    if ( indexedMode ) {\n      const { vertices } = frame;\n\n      polygons.map( ( { colorIndex, indices } ) => {\n        if ( currentColorIndex !== colorIndex ) {\n          if ( currentColorIndex !== -1 ) {\n            const colorHex = paletteInHex[ currentColorIndex ];\n            childrenStr += `<path d=\"${ d }\" fill=\"${ colorHex }\" />`;\n          }\n\n          currentColorIndex = colorIndex;\n          d = '';\n        }\n\n        for ( let i = 0; i < indices.length; i ++ ) {\n          const index = indices[ i ];\n          const x = vertices[ 2 * index ];\n          const y = vertices[ 2 * index + 1 ];\n\n          d += i === 0\n            ? `M${ x },${ y }`\n            : `L${ x },${ y }`;\n        }\n      } );\n    } else {\n      polygons.map( ( { colorIndex, vertices } ) => {\n        if ( currentColorIndex !== colorIndex ) {\n          if ( currentColorIndex !== -1 ) {\n            const colorHex = paletteInHex[ currentColorIndex ];\n            childrenStr += `<path d=\"${ d }\" fill=\"${ colorHex }\" />`;\n          }\n\n          currentColorIndex = colorIndex;\n          d = '';\n        }\n\n        for ( let i = 0; i < vertices.length; i += 2 ) {\n          const x = vertices[ i ];\n          const y = vertices[ i + 1 ];\n\n          d += i === 0\n            ? `M${ x },${ y }`\n            : `L${ x },${ y }`;\n        }\n      } );\n    }\n\n    const colorHex = paletteInHex[ currentColorIndex ];\n    childrenStr += `<path d=\"${ d }\" fill=\"${ colorHex }\" />`;\n\n    svg += `<g id=\"f${ iFrame }\">${ childrenStr }</g>`;\n  } );\n\n  svg += `<style>${style}</style></svg>`;\n\n  return svg;\n}\n", "/**\n * The naive implementation of so-called SmoothDamp.\n * Pretty much the same as {@link CDS}, but it has a way easier parameter to tweak, {@link smoothTime}.\n *\n * Ref: Game Programming Gems 4, Chapter 1.10\n *\n * See: https://github.com/Unity-Technologies/UnityCsReference/blob/a2bdfe9b3c4cd4476f44bf52f848063bfaf7b6b9/Runtime/Export/Math/Mathf.cs#L308\n */\nexport class SmoothDamp {\n  public smoothTime = 1.0;\n  public velocity = 0.0;\n  public value = 0.0;\n  public target = 0.0;\n\n  public update( deltaTime: number ): number {\n    const omega = 2.0 / this.smoothTime;\n    const x = omega * deltaTime;\n    const exp = 1.0 / ( 1.0 + x + 0.48 * x * x + 0.235 * x * x * x );\n    const delta = this.value - this.target;\n    const temp = ( this.velocity + omega * delta ) * deltaTime;\n    this.velocity = ( this.velocity - omega * temp ) * exp;\n    this.value = this.target + ( delta + temp ) * exp;\n    return this.value;\n  }\n}\n", "/**\n * Useful for swap buffer\n */\nexport class Swap<T> {\n  public i: T;\n  public o: T;\n\n  public constructor( a: T, b: T ) {\n    this.i = a;\n    this.o = b;\n  }\n\n  public swap(): void {\n    const i = this.i;\n    this.i = this.o;\n    this.o = i;\n  }\n}\n", "import { HistoryMeanCalculator } from '../HistoryMeanCalculator/HistoryMeanCalculator';\n\nexport class TapTempo {\n  private __bpm = 0.0;\n  private __lastTap = 0.0;\n  private __lastBeat = 0.0;\n  private __lastTime = 0.0;\n  private __calc: HistoryMeanCalculator = new HistoryMeanCalculator( 16 );\n\n  public get beatDuration(): number {\n    return 60.0 / this.__bpm;\n  }\n\n  public get bpm(): number {\n    return this.__bpm;\n  }\n\n  public set bpm( bpm: number ) {\n    this.__lastBeat = this.beat;\n    this.__lastTime = performance.now();\n    this.__bpm = bpm;\n  }\n\n  public get beat(): number {\n    return this.__lastBeat + ( performance.now() - this.__lastTime ) * 0.001 / this.beatDuration;\n  }\n\n  public reset(): void {\n    this.__calc.reset();\n  }\n\n  public nudge( amount: number ): void {\n    this.__lastBeat = this.beat + amount;\n    this.__lastTime = performance.now();\n  }\n\n  public tap(): void {\n    const now = performance.now();\n    const delta = ( now - this.__lastTap ) * 0.001;\n\n    if ( 2.0 < delta ) {\n      this.reset();\n    } else {\n      this.__calc.push( delta );\n      this.__bpm = 60.0 / ( this.__calc.mean );\n    }\n\n    this.__lastTap = now;\n    this.__lastTime = now;\n    this.__lastBeat = 0.0;\n  }\n}\n", "import { arraySerial } from '../array';\n\n/**\n * Parse a polyphonic tinyseq buffer.\n *\n * Returns [ time, offTime, note, reserved, time, offTime, note, reserved, ... ]\n */\nexport function createTinyseqPolyReader(\n  buffer: Uint8Array,\n  options: {\n    poly?: number,\n    blockSize?: number,\n    sampleRate?: number,\n    stepsPerSecond?: number,\n  } = {},\n): () => Float32Array[] {\n  const poly = options.poly ?? 8;\n  const blockSize = options.blockSize ?? 128;\n  const sampleRate = options.sampleRate ?? 48000;\n  const stepsPerSecond = options.stepsPerSecond ?? 1.0;\n\n  let samples = 0;\n  let pos = 0;\n  let note: number;\n  const notes = arraySerial( poly ).fill( -1 );\n  const notesTime = arraySerial( poly ).fill( -Infinity );\n  const notesOffTime = arraySerial( poly ).fill( -Infinity );\n  let nextStep = 0;\n\n  return () => {\n    const ret = arraySerial( poly ).map( () => new Float32Array( 4 * blockSize ) );\n\n    arraySerial( blockSize ).map( ( iSample ) => {\n      const t = samples / sampleRate;\n      const s = t * stepsPerSecond;\n\n      if ( s >= nextStep ) {\n        const eventNote = buffer[ pos ];\n        const eventDeltaStep = buffer[ pos + 1 ];\n\n        note = ( ( pos === 0 ? 60 : note ) + eventNote ) & 127;\n\n        // find same note\n        let iPoly = notes.indexOf( note );\n\n        // find earliest note off\n        let tEarliest = Infinity;\n\n        if ( iPoly === -1 ) {\n          notesTime.map( ( tOn, jPoly ) => {\n            const tOff = notesOffTime[ jPoly ];\n            if ( tOn <= tOff ) {\n              if ( tOff < tEarliest ) {\n                iPoly = jPoly;\n                tEarliest = tOff;\n              }\n            }\n          } );\n        }\n\n        // find earliest note on\n        if ( iPoly === -1 ) {\n          notesTime.map( ( tOn, jPoly ) => {\n            if ( tOn < tEarliest ) {\n              iPoly = jPoly;\n              tEarliest = tOn;\n            }\n          } );\n        }\n\n        notes[ iPoly ] = note;\n\n        if ( eventNote & 128 ) {\n          if ( notesOffTime[ iPoly ] < notesTime[ iPoly ] ) {\n            notesOffTime[ iPoly ] = t;\n          }\n        } else {\n          if ( notesOffTime[ iPoly ] >= notesTime[ iPoly ] ) {\n            notesTime[ iPoly ] = t;\n          }\n        }\n\n        nextStep += eventDeltaStep;\n\n        pos = ( pos + 2 ) % buffer.length;\n      }\n\n      samples ++;\n\n      arraySerial( poly ).map( ( iPoly ) => {\n        const noteTime = notesTime[ iPoly ];\n        const noteOffTime = notesOffTime[ iPoly ];\n\n        ret[ iPoly ][ 4 * iSample + 0 ] = t - noteTime; // time\n        ret[ iPoly ][ 4 * iSample + 1 ] = noteOffTime < noteTime ? 0.0 : t - noteOffTime; // offTime\n        ret[ iPoly ][ 4 * iSample + 2 ] = notes[ iPoly ]; // note\n        ret[ iPoly ][ 4 * iSample + 3 ] = 0.0; // reserved\n      } );\n    } );\n\n    return ret;\n  };\n}\n", "import { arraySerial } from '../array';\n\n/**\n * Parse a tinyseq buffer.\n *\n * Returns [ time, offTime, note, reserved, time, offTime, note, reserved, ... ]\n */\nexport function createTinyseqReader(\n  buffer: Uint8Array,\n  options: {\n    blockSize?: number,\n    sampleRate?: number,\n    stepsPerSecond?: number,\n  } = {},\n): () => Float32Array {\n  const blockSize = options.blockSize ?? 128;\n  const sampleRate = options.sampleRate ?? 48000;\n  const stepsPerSecond = options.stepsPerSecond ?? 960.0;\n\n  let samples = 0;\n  let pos = 0;\n  let note: number;\n  let noteTime = -Infinity;\n  let noteOffTime = -Infinity;\n  let nextStep = 0;\n\n  return () => {\n    return new Float32Array( arraySerial( blockSize ).map( () => {\n      const t = samples / sampleRate;\n      const s = t * stepsPerSecond;\n\n      if ( s >= nextStep ) {\n        const eventNote = buffer[ pos ];\n        const eventDeltaStep = buffer[ pos + 1 ];\n\n        note = ( ( pos === 0 ? 60 : note ) + eventNote ) & 127;\n        if ( eventNote & 128 ) {\n          if ( noteOffTime < noteTime ) {\n            noteOffTime = t;\n          }\n        } else {\n          if ( noteOffTime >= noteTime ) {\n            noteTime = t;\n          }\n        }\n\n        nextStep += eventDeltaStep;\n\n        pos = ( pos + 2 ) % buffer.length;\n      }\n\n      samples ++;\n\n      return [\n        t - noteTime, // time\n        noteOffTime < noteTime ? 0.0 : t - noteOffTime, // offTime\n        note, // note\n        0.0, // reserved\n      ];\n    } ).flat() );\n  };\n}\n", "import { MidiParseResult } from '../midi';\nimport { arraySerial } from '../array';\n\n/**\n * Convert the parsed midi result to a tinyseq binary.\n *\n * See: {@link midiParse}\n *\n * @param midi The parsed midi result\n * @param track The index of the midi track you want to convert\n * @param tickMultiplier Multiply this value to tick\n * @returns A tinyseq binary\n */\nexport function tinyseqFromMidiParseResult(\n  midi: MidiParseResult,\n  { track, tickMultiplier }: {\n    track?: number,\n    tickMultiplier?: number,\n  } = {},\n): Uint8Array {\n  const data: number[] = [];\n  let lastNote = 60;\n  let delta = 0;\n\n  const trackEvents = midi[ 1 ][ track ?? 0.0 ];\n\n  // [ delta, midi event, note, vel ][] -> [ onoff (0 or 128) + deltaNote, delta, ... ]\n  // [ [ 4, 144, 60, 100 ], [ 4, 128, 60, 100 ] ] -> [ 128, 4, 0, 4, 128, 0 ]\n\n  arraySerial( trackEvents.length + 1 ).map( ( i ) => {\n    delta += ( trackEvents[ i ]?.[ 0 ] ?? 0 ) * ( tickMultiplier ?? 1.0 );\n\n    if ( delta === 0 && i === 0 ) { return; } // ignore if it's the first event and delta is 0\n\n    const evMsg = trackEvents[ i - 1 ]?.[ 1 ] ?? 128;\n    const evNote = trackEvents[ i - 1 ]?.[ 2 ] ?? 60;\n\n    if ( evMsg >= 160 ) { return; } // ignore if the msg is not a note event\n\n    const noteDelta = ( evNote - lastNote + 128 ) & 127;\n    lastNote = evNote;\n    const onoff = evMsg < 144 ? 128 : 0; // 0 if on (144 - 159), 128 if off (128 - 143)\n\n    // probably 240 is more efficient than 256 since the division in most of midi files are 480 or 960\n    let deltaConsume = Math.floor( Math.min( delta, 240 ) );\n    data.push( noteDelta + onoff, deltaConsume );\n    delta -= deltaConsume;\n\n    while ( delta >= 1 ) {\n      deltaConsume = Math.floor( Math.min( delta, 240 ) );\n      data.push( onoff, deltaConsume );\n      delta -= deltaConsume;\n    }\n  } );\n\n  return new Uint8Array( data );\n}\n", "export class Xorshift {\n  public seed: number;\n\n  public constructor( seed?: number ) {\n    this.seed = seed || 1;\n  }\n\n  public gen( seed?: number ): number {\n    if ( seed ) {\n      this.seed = seed;\n    }\n\n    this.seed = this.seed ^ ( this.seed << 13 );\n    this.seed = this.seed ^ ( this.seed >>> 17 );\n    this.seed = this.seed ^ ( this.seed << 5 );\n    return this.seed / Math.pow( 2, 32 ) + 0.5;\n  }\n\n  public set( seed?: number ): void {\n    this.seed = seed || this.seed || 1;\n  }\n}\n\nexport default Xorshift;\n", "import { linearstep } from '../math/utils';\n\n/**\n * https://twitter.com/yugop\n *\n * @param text The input text\n * @param phase The value between 0.0 and 1.0\n * @param randomRatio The nerd value\n */\nexport function getYugopText( text: string, phase: number, randomRatio = 0.5 ): string {\n  if ( phase >= 1.0 ) { return text; }\n  if ( phase < 0.0 ) { return ''; }\n\n  /*\n   * ------=====\n   * .------====\n   * ..------===\n   * ...------==\n   * ....------=\n   * ^     ^   ^\n   * |     |   |\n   * |     |   phase is 1.0\n   * |     phase is randomRatio\n   * phase is 0.0\n   */\n\n  const displayTween = linearstep( 0.0, 1.0 - randomRatio, phase );\n  const fixTween = linearstep( randomRatio, 1.0, phase );\n\n  const displayLength = 1.0 + Math.floor( displayTween * ( text.length - 1 ) );\n  const fixLength = phase < randomRatio ? 0 : 1.0 + Math.floor( fixTween * ( text.length - 1 ) );\n  const randomLength = displayLength - fixLength;\n\n  const randomStr = [ ...Array( randomLength ) ]\n    .map( () => String.fromCharCode( 33 + Math.floor( 93 * Math.random() ) ) )\n    .join( '' );\n\n  return text.substring( 0, fixLength ) + randomStr;\n}\n", "export class BinaryHeap<T> {\n  public readonly array: T[];\n  public readonly elementIndexMap: Map<T, number>;\n  public comparator: ( a: T, b: T ) => number;\n\n  public static defaultComparator( a: any, b: any ): number {\n    const aStr = `${ a }`;\n    const bStr = `${ b }`;\n\n    if ( aStr > bStr ) {\n      return 1;\n    } else if ( aStr < bStr ) {\n      return -1;\n    } else {\n      return 0;\n    }\n  }\n\n  public get length(): number {\n    return this.array.length;\n  }\n\n  public get isEmpty(): boolean {\n    return this.array.length === 0;\n  }\n\n  public get root(): T {\n    return this.array[ 0 ];\n  }\n\n  public constructor( init?: T[], comparator?: ( a: T, b: T ) => number ) {\n    this.array = [];\n    this.elementIndexMap = new Map();\n    this.comparator = comparator ?? BinaryHeap.defaultComparator;\n\n    if ( init != null ) {\n      for ( const el of init ) {\n        this.push( el );\n      }\n    }\n  }\n\n  public push( ...elements: T[] ): void {\n    elements.map( ( el ) => {\n      const i = this.length;\n      this.array.push( el );\n      this.elementIndexMap.set( el, i );\n      this.__up( i, el );\n    } );\n  }\n\n  public pop(): T | null {\n    if ( this.isEmpty ) {\n      return null;\n    }\n\n    const el = this.array[ 0 ];\n    this.elementIndexMap.delete( el );\n\n    if ( this.length === 1 ) {\n      this.array.splice( 0 );\n    } else {\n      const rep = this.array.pop();\n      this.__down( 0, rep! );\n    }\n\n    return el;\n  }\n\n  public delete( i: number ): boolean {\n    this.elementIndexMap.delete( this.array[ i ] );\n\n    const rep = this.array.pop();\n    if ( rep != null ) {\n      i = this.__up( i, rep );\n      i = this.__down( i, rep );\n    }\n\n    return true;\n  }\n\n  public replace( i: number, rep: T ): number | null {\n    if ( i != null ) {\n      this.elementIndexMap.delete( this.array[ i ] );\n\n      i = this.__up( i, rep );\n      i = this.__down( i, rep );\n    }\n\n    return i ?? null;\n  }\n\n  private __up( i: number, el: T ): number {\n    let ic = i;\n\n    while ( ic !== 0 ) {\n      const ip = ( ic - 1 ) >> 1;\n\n      const p = this.array[ ip ];\n      if ( this.comparator( el, p ) < 0 ) {\n        this.array[ ic ] = p;\n        this.elementIndexMap.set( p, ic );\n        ic = ip;\n      } else {\n        break;\n      }\n    }\n\n    this.array[ ic ] = el;\n    this.elementIndexMap.set( el, ic );\n    return ic;\n  }\n\n  private __down( i: number, el: T ): number {\n    let ip = i;\n\n    while ( ( ip << 1 ) + 1 < this.length ) {\n      const ic1 = ( ip << 1 ) + 1;\n      const ic2 = ( ip << 1 ) + 2;\n\n      if ( ic2 < this.length ) {\n        const c1 = this.array[ ic1 ];\n        const c2 = this.array[ ic2 ];\n\n        const pickLeft = this.comparator( c1, c2 ) < 0;\n        const c = pickLeft ? c1 : c2;\n        const ic = pickLeft ? ic1 : ic2;\n\n        if ( this.comparator( c, el ) < 0 ) {\n          this.array[ ip ] = c;\n          this.elementIndexMap.set( c, ip );\n          ip = ic;\n        } else {\n          break;\n        }\n      } else if ( this.comparator( this.array[ ic1 ], el ) < 0 ) {\n        this.array[ ip ] = this.array[ ic1 ];\n        this.elementIndexMap.set( this.array[ ip ], ip );\n        ip = ic1;\n      } else {\n        break;\n      }\n    }\n\n    this.array[ ip ] = el;\n    this.elementIndexMap.set( el, ip );\n    return ip;\n  }\n}\n", "/**\n * A bare function to notify observers.\n * The incredibly cheap implementation of the observer pattern.\n *\n * @example\n * ```ts\n * const observers = new Set<( text: string ) => void>();\n *\n * observers.add( ( text ) => console.log( text ) );\n * observers.add( ( text ) => alert( text ) );\n *\n * notifyObservers( observers, 'wenis' );\n * ```\n *\n * @param observers The iterator of observers\n * @param param The param you want to give to observers\n */\nexport function notifyObservers( observers: Iterable<() => void> ): void;\nexport function notifyObservers<T>( observers: Iterable<( arg: T ) => void>, param: T ): void;\nexport function notifyObservers( observers: Iterable<( arg: any ) => void>, param?: any ): void {\n  for ( const observer of observers ) {\n    observer( param );\n  }\n}\n", "export const shaderchunkPre = `#version 300 es\n\nprecision highp float;\n\n#define _PI 3.14159265359\n\nuniform float bpm;\nuniform vec4 timeLength;\nuniform float sampleRate;\nuniform float _deltaSample;\nuniform vec4 _timeHead;\n\nin float off;\n\nout float outL;\nout float outR;\n\nfloat paramFetch( vec4 param ) {\n  return mix( param.x, param.y, exp( -param.z * off * _deltaSample ) );\n}\n\nfloat wavetableNearest( sampler2D w, vec4 meta, vec2 position ) {\n  vec2 uv0 = fract( vec2(\n    position.x,\n    ( floor( fract( position.y ) * ( meta.y - 1.0 ) ) + 0.5 ) / meta.y\n  ) );\n  vec2 uv1 = uv0 + vec2( 0.0, 1.0 / meta.y );\n  return mix(\n    texture( w, uv0 ).x,\n    texture( w, uv1 ).x,\n    fract( position.y * ( meta.y - 1.0 ) )\n  );\n}\n\nfloat wavetableSinc( sampler2D w, vec4 meta, vec2 position ) {\n  float sum = 0.0;\n  float def = -fract( position.x * meta.x );\n  for ( int i = -5; i <= 5; i ++ ) {\n    float x = floor( position.x * meta.x + float( i ) ) / meta.x;\n    float deft = def + float( i );\n    vec2 uv0 = fract( vec2(\n      x,\n      ( floor( fract( position.y ) * ( meta.y - 1.0 ) ) + 0.5 ) / meta.y\n    ) );\n    vec2 uv1 = uv0 + vec2( 0.0, 1.0 / meta.y );\n    sum += mix(\n      texture( w, uv0 ).x,\n      texture( w, uv1 ).x,\n      fract( position.y * ( meta.y - 1.0 ) )\n    ) * min( sin( deft * _PI ) / deft / _PI, 1.0 );\n  }\n  return sum;\n}\n\nvec2 sampleNearest( sampler2D s, vec4 meta, float time ) {\n  if ( meta.w < time ) { return vec2( 0.0 ); }\n  float x = time / meta.x * meta.z;\n  vec2 uv = fract( vec2(\n    x,\n    floor( x ) / meta.y\n  ) ) + 0.5 / meta.xy;\n  return texture( s, uv ).xy;\n}\n\nvec2 sampleSinc( sampler2D s, vec4 meta, float time ) {\n  if ( meta.w < time ) { return vec2( 0.0 ); }\n  vec2 sum = vec2( 0.0 );\n  float def = -fract( time * meta.z );\n  for ( int i = -5; i <= 5; i ++ ) {\n    float x = floor( time * meta.z + float( i ) ) / meta.x;\n    float deft = def + float( i );\n    vec2 uv = fract( vec2(\n      x,\n      floor( x ) / meta.y\n    ) ) + 0.5 / meta.xy;\n    sum += texture( s, uv ).xy * min( sin( deft * _PI ) / deft / _PI, 1.0 );\n  }\n  return sum;\n}\n`;\n\nexport const shaderchunkPreLines = shaderchunkPre.split( '\\n' ).length;\n\nexport const shaderchunkPost = `void main() {\n  vec2 out2 = mainAudio( mod( _timeHead + off * _deltaSample, timeLength ) );\n  outL = out2.x;\n  outR = out2.y;\n}`;\n", "export function glWaitGPUCommandsCompleteAsync( gl: WebGL2RenderingContext ): Promise<void> {\n  const sync = gl.fenceSync( gl.SYNC_GPU_COMMANDS_COMPLETE, 0 )!;\n\n  return new Promise( ( resolve, reject ) => {\n    const test = (): void => {\n      const res = gl.clientWaitSync( sync, 0, 0 );\n      if ( res === gl.WAIT_FAILED ) {\n        reject();\n        return;\n      }\n      if ( res === gl.TIMEOUT_EXPIRED ) {\n        setTimeout( test, 10 );\n        return;\n      }\n      gl.deleteSync( sync );\n      resolve();\n    };\n\n    test();\n  } );\n}\n", "export function lazyProgram(\n  gl: WebGL2RenderingContext,\n  vert: string,\n  frag: string,\n  options: {\n    /**\n     * `KHR_parallel_shader_compile`.\n     * Compile async if provided.\n     */\n    extParallel?: any,\n\n    tfVaryings?: string[],\n\n    /**\n     * `gl.SEPARATE_ATTRIBS` by default\n     */\n    tfBufferMode?: number,\n  } = {},\n): Promise<WebGLProgram> {\n  const { extParallel, tfVaryings, tfBufferMode } = options;\n\n  let vertexShader: WebGLShader | null = null;\n  let fragmentShader: WebGLShader | null = null;\n  let program: WebGLProgram | null = null;\n\n  try {\n    // == vert =====================================================================================\n    vertexShader = gl.createShader( gl.VERTEX_SHADER )!;\n\n    gl.shaderSource( vertexShader, vert );\n    gl.compileShader( vertexShader );\n\n    if ( !gl.getShaderParameter( vertexShader, gl.COMPILE_STATUS ) ) {\n      throw new Error( gl.getShaderInfoLog( vertexShader ) ?? undefined );\n    }\n\n    // == frag =====================================================================================\n    fragmentShader = gl.createShader( gl.FRAGMENT_SHADER )!;\n\n    gl.shaderSource( fragmentShader, frag );\n    gl.compileShader( fragmentShader );\n\n    if ( !gl.getShaderParameter( fragmentShader, gl.COMPILE_STATUS ) ) {\n      throw new Error( gl.getShaderInfoLog( fragmentShader ) ?? undefined );\n    }\n\n    // == program ==================================================================================\n    program = gl.createProgram()!;\n\n    gl.attachShader( program, vertexShader );\n    gl.attachShader( program, fragmentShader );\n\n    if ( tfVaryings ) {\n      gl.transformFeedbackVaryings(\n        program,\n        tfVaryings,\n        tfBufferMode ?? gl.SEPARATE_ATTRIBS,\n      );\n    }\n\n    gl.linkProgram( program );\n\n    return new Promise( ( resolve, reject ) => {\n      const update = () => {\n        if (\n          !extParallel ||\n          gl.getProgramParameter( program!, extParallel.COMPLETION_STATUS_KHR ) === true\n        ) {\n          if ( !gl.getProgramParameter( program!, gl.LINK_STATUS ) ) {\n            gl.deleteProgram( program );\n            reject( new Error( gl.getProgramInfoLog( program! ) ?? undefined ) );\n          } else {\n            resolve( program! );\n          }\n\n          return;\n        }\n\n        setTimeout( update, 10 );\n      };\n      update();\n    } );\n  } catch ( e ) {\n    gl.deleteProgram( program );\n\n    return Promise.reject( e );\n  } finally {\n    gl.deleteShader( fragmentShader );\n    gl.deleteShader( vertexShader );\n  }\n}\n", "import { Pool, arraySerial } from '@0b5vr/experimental';\nimport { shaderchunkPost, shaderchunkPre } from './shaderchunks';\nimport { glWaitGPUCommandsCompleteAsync } from './utils/glWaitGPUCommandsCompleteAsync';\nimport { lazyProgram } from './utils/lazyProgram';\n\nconst BLOCK_SIZE = 128;\nconst POOL_SIZE = 128;\n\nexport interface TFPoolEntry {\n  bufferL: WebGLBuffer;\n  bufferR: WebGLBuffer;\n  tf: WebGLTransformFeedback;\n  dstArrays: [ Float32Array, Float32Array ];\n}\n\n// -- utils ----------------------------------------------------------------------------------------\nfunction createOffsetBuffer( gl: WebGL2RenderingContext, length: number ): WebGLBuffer {\n  const array = new Float32Array( arraySerial( length ) );\n\n  const buffer = gl.createBuffer()!;\n\n  gl.bindBuffer( gl.ARRAY_BUFFER, buffer );\n  gl.bufferData( gl.ARRAY_BUFFER, array, gl.STATIC_DRAW );\n  gl.bindBuffer( gl.ARRAY_BUFFER, null );\n\n  return buffer;\n}\n\nfunction createTFBuffer( gl: WebGL2RenderingContext, length: number ): WebGLBuffer {\n  const buffer = gl.createBuffer()!;\n\n  gl.bindBuffer( gl.ARRAY_BUFFER, buffer );\n  gl.bufferData(\n    gl.ARRAY_BUFFER,\n    length * Float32Array.BYTES_PER_ELEMENT,\n    gl.STREAM_READ,\n  );\n  gl.bindBuffer( gl.ARRAY_BUFFER, null );\n\n  return buffer;\n}\n\nfunction createTFPoolEntry( gl: WebGL2RenderingContext, length: number ): TFPoolEntry {\n  const bufferL = createTFBuffer( gl, length );\n  const bufferR = createTFBuffer( gl, length );\n\n  const tf = gl.createTransformFeedback()!;\n\n  const dstArrays = [\n    new Float32Array( length ),\n    new Float32Array( length ),\n  ] as [ Float32Array, Float32Array ];\n\n  return { bufferL, bufferR, tf, dstArrays };\n}\n\n// -- class ----------------------------------------------------------------------------------------\nexport class Renderer {\n  public readonly gl: WebGL2RenderingContext;\n  public readonly blocksPerRender: number;\n\n  public useSync: boolean;\n\n  public readonly __extParallel: any;\n  public readonly __tfPool: Pool<TFPoolEntry>;\n\n  public get framesPerRender(): number {\n    return BLOCK_SIZE * this.blocksPerRender;\n  }\n\n  private __offsetBuffer: WebGLBuffer;\n\n  private __program: WebGLProgram | null;\n  private __programCue: WebGLProgram | null;\n\n  public constructor( gl: WebGL2RenderingContext, blocksPerRender: number ) {\n    this.blocksPerRender = blocksPerRender;\n\n    this.gl = gl;\n\n    this.useSync = false;\n\n    this.__tfPool = new Pool( arraySerial( POOL_SIZE ).map( () => (\n      createTFPoolEntry( gl, this.framesPerRender )\n    ) ) );\n\n    this.__extParallel = gl.getExtension( 'KHR_parallel_shader_compile' );\n\n    this.__offsetBuffer = createOffsetBuffer( gl, this.framesPerRender );\n\n    this.__program = null;\n    this.__programCue = null;\n  }\n\n  /**\n   * Dispose the renderer.\n   */\n  public dispose(): void {\n    const { gl } = this;\n\n    gl.deleteBuffer( this.__offsetBuffer );\n\n    for ( const { bufferL, bufferR, tf } of this.__tfPool.array ) {\n      gl.deleteBuffer( bufferL );\n      gl.deleteBuffer( bufferR );\n      gl.deleteTransformFeedback( tf );\n    }\n\n    gl.deleteProgram( this.__program );\n    gl.deleteProgram( this.__programCue );\n  }\n\n  /**\n   * Get a tfPoolEntry.\n   */\n  public getNextTFPoolEntry(): TFPoolEntry {\n    return this.__tfPool.next();\n  }\n\n  /**\n   * Compile given shader code and cue the shader.\n   */\n  public async compile( code: string ): Promise<void> {\n    const { gl } = this;\n\n    const program = await lazyProgram(\n      gl,\n      shaderchunkPre + code + shaderchunkPost,\n      '#version 300 es\\nvoid main(){discard;}',\n      {\n        extParallel: this.__extParallel,\n        tfVaryings: [ 'outL', 'outR' ],\n      },\n    ).catch( ( error ) => {\n      this.__programCue = null;\n      gl.deleteProgram( this.__programCue );\n\n      throw error;\n    } );\n\n    if ( program == null ) { return; }\n\n    this.__programCue = program;\n  }\n\n  /**\n   * Apply the cue shader.\n   *\n   * It does not do nothing when cue is not set.\n   * Feel free to mash this method for no reason.\n   */\n  public applyCue(): void {\n    const { gl } = this;\n\n    if ( this.__programCue == null ) { return; }\n\n    const prevProgram = this.__program;\n    this.__program = this.__programCue;\n\n    if ( prevProgram != null ) {\n      gl.deleteProgram( prevProgram );\n    }\n    this.__programCue = null;\n  }\n\n  /**\n   * Set an uniform1f to the current program.\n   */\n  public uniform1f( name: string, value: number ): void {\n    const { gl, __program: program } = this;\n    if ( program == null ) { return; }\n\n    const location = gl.getUniformLocation( program, name );\n\n    gl.useProgram( program );\n    gl.uniform1f( location, value );\n    gl.useProgram( null );\n  }\n\n  /**\n   * Set an uniform4f to the current program.\n   */\n  public uniform4f( name: string, ...value: [ number, number, number, number ] ): void {\n    const { gl, __program: program } = this;\n    if ( program == null ) { return; }\n\n    const location = gl.getUniformLocation( program, name );\n\n    gl.useProgram( program );\n    gl.uniform4f( location, ...value );\n    gl.useProgram( null );\n  }\n\n  /**\n   * Set a texture uniform to the current program.\n   */\n  public uniformTexture( name: string, unit: number, texture: WebGLTexture ): void {\n    const { gl, __program: program } = this;\n    if ( program == null ) { return; }\n\n    const location = gl.getUniformLocation( program, name );\n\n    gl.activeTexture( gl.TEXTURE0 + unit );\n    gl.bindTexture( gl.TEXTURE_2D, texture );\n\n    gl.useProgram( program );\n    gl.uniform1i( location, unit );\n    gl.useProgram( null );\n  }\n\n  /**\n   * Render and return a buffer.\n   */\n  public render( tfPoolEntry: TFPoolEntry, first: number, count: number ): void {\n    const { gl, __program: program } = this;\n    const { bufferL, bufferR, tf } = tfPoolEntry;\n\n    if ( program == null ) {\n      return;\n    }\n\n    // -- attrib -----------------------------------------------------------------------------------\n    const attribLocation = gl.getAttribLocation( program, 'off' );\n\n    gl.bindBuffer( gl.ARRAY_BUFFER, this.__offsetBuffer );\n    gl.enableVertexAttribArray( attribLocation );\n    gl.vertexAttribPointer( attribLocation, 1, gl.FLOAT, false, 0, 0 );\n\n    // -- render -----------------------------------------------------------------------------------\n    gl.useProgram( program );\n\n    gl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, tf );\n    gl.bindBufferRange( gl.TRANSFORM_FEEDBACK_BUFFER, 0, bufferL, 4 * first, 4 * count );\n    gl.bindBufferRange( gl.TRANSFORM_FEEDBACK_BUFFER, 1, bufferR, 4 * first, 4 * count );\n    gl.enable( gl.RASTERIZER_DISCARD );\n\n    gl.beginTransformFeedback( gl.POINTS );\n    gl.drawArrays( gl.POINTS, first, count );\n    gl.endTransformFeedback();\n\n    gl.disable( gl.RASTERIZER_DISCARD );\n    gl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, null );\n    gl.useProgram( null );\n  }\n\n  public async readBuffer( { bufferL, bufferR, dstArrays }: TFPoolEntry ): Promise<void> {\n    const { gl } = this;\n\n    if ( this.useSync ) {\n      await glWaitGPUCommandsCompleteAsync( gl );\n    }\n\n    gl.bindBuffer( gl.ARRAY_BUFFER, bufferL );\n    gl.getBufferSubData(\n      gl.ARRAY_BUFFER,\n      0,\n      dstArrays[ 0 ],\n      0,\n      this.framesPerRender,\n    );\n    gl.bindBuffer( gl.ARRAY_BUFFER, null );\n\n    gl.bindBuffer( gl.ARRAY_BUFFER, bufferR );\n    gl.getBufferSubData(\n      gl.ARRAY_BUFFER,\n      0,\n      dstArrays[ 1 ],\n      0,\n      this.framesPerRender,\n    );\n    gl.bindBuffer( gl.ARRAY_BUFFER, null );\n  }\n}\n", "// Ref: https://github.com/andywer/typed-emitter/blob/master/index.d.ts\n\nexport type EventListener<T> = ( event: T ) => void;\n\nexport class EventEmittable<TEvents extends { [ type: string ]: any }> {\n  protected __eventListeners?: Map<keyof TEvents, EventListener<any>[]>;\n\n  public on<TType extends keyof TEvents & string>(\n    type: TType,\n    listener: EventListener<TEvents[ TType ]>\n  ): EventListener<TEvents[ TType ]> {\n    this.__eventListeners = this.__eventListeners || new Map();\n    let array = this.__eventListeners.get( type );\n    if ( !array ) {\n      array = [];\n      this.__eventListeners.set( type, array );\n    }\n\n    array.push( listener );\n\n    return listener;\n  }\n\n  public off<TType extends keyof TEvents & string>(\n    type: TType,\n    listener: EventListener<TEvents[ TType ]>\n  ): void {\n    this.__eventListeners = this.__eventListeners || new Map();\n    let array = this.__eventListeners.get( type );\n    if ( !array ) {\n      array = [];\n      this.__eventListeners.set( type, array );\n    }\n\n    const index = array.indexOf( listener );\n    if ( index !== -1 ) {\n      array.splice( index, 1 );\n    }\n  }\n\n  protected __emit<TType extends keyof TEvents>(\n    ...[ type, event ]: TEvents[ TType ] extends void ? [ TType ] : [ TType, TEvents[ TType ] ]\n  ): void {\n    this.__eventListeners = this.__eventListeners || new Map();\n    this.__eventListeners.get( type )?.forEach( ( listener ) => listener( event ) );\n  }\n}\n", "export function applyMixins( derivedCtor: any, baseCtors: any[] ): void {\n  baseCtors.forEach( ( baseCtor ) => {\n    Object.getOwnPropertyNames( baseCtor.prototype ).forEach( ( name ) => {\n      Object.defineProperty(\n        derivedCtor.prototype,\n        name,\n        Object.getOwnPropertyDescriptor( baseCtor.prototype, name )!\n      );\n    } );\n  } );\n}\n", "export function mod( value: number, divisor: number ): number {\n  return value - Math.floor( value / divisor ) * divisor;\n}\n", "import { EventEmittable } from './utils/EventEmittable';\nimport { applyMixins } from './utils/applyMixins';\nimport { mod } from './utils/mod';\n\nexport interface BeatManagerUpdateEvent {\n  time: number;\n  bpm: number;\n  beat: number;\n  bar: number;\n  sixteenBar: number;\n}\n\nexport class BeatManager {\n  public static CalcBeatSeconds( bpm: number ): number {\n    return 60.0 / bpm;\n  }\n\n  public static CalcBarSeconds( bpm: number ): number {\n    // return this.beatLength * 4.0;\n    return 240.0 / bpm;\n  }\n\n  public static CalcSixteenBarSeconds( bpm: number ): number {\n    // return this.barLength * 16.0;\n    return 3840.0 / bpm;\n  }\n\n  private __bpm = 140.0;\n  public get bpm(): number {\n    return this.__bpm;\n  }\n  public set bpm( value: number ) {\n    const prevBpm = this.__bpm;\n    this.__bpm = Math.max( 0.0, value );\n    this.__sixteenBar = this.__sixteenBar * prevBpm / this.__bpm;\n    this.__emit( 'changeBPM', { bpm: this.__bpm } );\n  }\n\n  public get beatSeconds(): number {\n    return BeatManager.CalcBeatSeconds( this.__bpm );\n  }\n\n  public get barSeconds(): number {\n    return BeatManager.CalcBarSeconds( this.__bpm );\n  }\n\n  public get sixteenBarSeconds(): number {\n    return BeatManager.CalcSixteenBarSeconds( this.__bpm );\n  }\n\n  private __time = 0.0;\n  public get time(): number {\n    return this.__time;\n  }\n\n  private __beat = 0.0;\n  public get beat(): number {\n    return this.__beat;\n  }\n\n  private __bar = 0.0;\n  public get bar(): number {\n    return this.__bar;\n  }\n\n  private __sixteenBar = 0.0;\n  public get sixteenBar(): number {\n    return this.__sixteenBar;\n  }\n\n  public reset(): void {\n    this.__time = 0.0;\n    this.__sixteenBar = 0.0;\n  }\n\n  public update( time: number ): BeatManagerUpdateEvent {\n    const beatSeconds = BeatManager.CalcBeatSeconds( this.__bpm );\n    const barSeconds = BeatManager.CalcBarSeconds( this.__bpm );\n    const sixteenBarSeconds = BeatManager.CalcSixteenBarSeconds( this.__bpm );\n\n    const delta = time - this.__time;\n\n    this.__sixteenBar = mod( this.__sixteenBar + delta, sixteenBarSeconds );\n    this.__bar = mod( this.__sixteenBar, barSeconds );\n    this.__beat = mod( this.__bar, beatSeconds );\n\n    this.__time = time;\n\n    const event = {\n      time,\n      bpm: this.__bpm,\n      beat: this.__beat,\n      bar: this.__bar,\n      sixteenBar: this.__sixteenBar,\n    };\n\n    this.__emit( 'update', event );\n\n    return event;\n  }\n}\n\nexport interface BeatManager extends EventEmittable<{\n  update: BeatManagerUpdateEvent;\n  changeBPM: { bpm: number };\n}> {}\napplyMixins( BeatManager, [ EventEmittable ] );\n", "import processorCode from './BufferReaderProcessor.worklet.js';\n\nconst BLOCK_SIZE = 128;\nconst CHANNELS = 2;\nconst BUFFER_SIZE_PER_CHANNEL = 65536;\n\nconst processorBlob = new Blob( [ processorCode ], { type: 'text/javascript' } );\nconst processorUrl = URL.createObjectURL( processorBlob );\n\nexport class BufferReaderNode extends AudioWorkletNode {\n  private __readBlocks: number;\n\n  public get readBlocks(): number {\n    return this.__readBlocks;\n  }\n\n  public static addModule( audio: AudioContext ): Promise<void> {\n    return audio.audioWorklet.addModule( processorUrl );\n  }\n\n  public setActive( isActive: boolean ): void {\n    this.port.postMessage( isActive );\n  }\n\n  public constructor( audio: AudioContext ) {\n    super( audio, 'buffer-reader-processor', {\n      numberOfInputs: 0,\n      numberOfOutputs: 1,\n      outputChannelCount: [ CHANNELS ],\n    } );\n\n    this.__readBlocks = 0;\n\n    this.port.onmessage = ( ( { data } ) => {\n      this.__readBlocks = data;\n    } );\n  }\n\n  public write( channel: number, block: number, offset: number, buffer: ArrayLike<number> ): void {\n    const totalOffset = (\n      BUFFER_SIZE_PER_CHANNEL * channel\n      + ( BLOCK_SIZE * block ) % BUFFER_SIZE_PER_CHANNEL\n      + offset\n    );\n    this.port.postMessage( [ buffer, totalOffset ] );\n  }\n}\n", "import { TextureStoreEntry, TextureStoreImageEntry, TextureStoreSampleEntry, TextureStoreWavetableEntry } from './TextureStoreEntry';\n\nexport class TextureStore {\n  public readonly gl: WebGL2RenderingContext;\n\n  private __textures: Map<string, TextureStoreEntry>;\n\n  public get textureIds(): IterableIterator<string> {\n    return this.__textures.keys();\n  }\n\n  public constructor( gl: WebGL2RenderingContext ) {\n    this.gl = gl;\n\n    this.__textures = new Map();\n  }\n\n  /**\n   * Dispose all the textures.\n   */\n  public dispose(): void {\n    const { gl } = this;\n\n    this.__textures.forEach( ( texture ) => {\n      gl.deleteTexture( texture.texture );\n    } );\n\n    this.__textures.clear();\n  }\n\n  /**\n   * Get a texture.\n   */\n  public get( id: string ): TextureStoreEntry | null {\n    return this.__textures.get( id ) ?? null;\n  }\n\n  /**\n   * Load a x-y wavetable and store as a texture.\n   * The buffer have to be encoded in F32, 2048 samples per cycle.\n   *\n   * The texture name is gonna be `wavetable_${ name }`.\n   */\n  public loadWavetable( id: string, inputBuffer: Float32Array ): TextureStoreWavetableEntry {\n    const frames = inputBuffer.length / 2048;\n    const buffer = new Float32Array( inputBuffer.length * 4 );\n\n    for ( let i = 0; i < inputBuffer.length; i ++ ) {\n      buffer[ i * 4 + 0 ] = inputBuffer[ i ];\n    }\n\n    const texture = this.__uploadTexture( 2048, frames, buffer );\n\n    const entry = {\n      type: 'wavetable' as const,\n      width: 2048,\n      height: frames,\n      texture,\n    };\n    this.__textures.set( id, entry );\n    return entry;\n  }\n\n  /**\n   * Load an image and store as a texture.\n   */\n  public loadImage( id: string, image: TexImageSource ): TextureStoreImageEntry {\n    const texture = this.__uploadImageSource( image );\n\n    const entry = {\n      type: 'image' as const,\n      width: image.width,\n      height: image.height,\n      texture,\n    };\n    this.__textures.set( id, entry );\n    return entry;\n  }\n\n  /**\n   * Load a sample and store as a texture.\n   */\n  public loadSample( id: string, audioBuffer: AudioBuffer ): TextureStoreSampleEntry {\n    const { sampleRate, duration } = audioBuffer;\n    const frames = audioBuffer.length;\n    const width = 2048;\n    const lengthCeiled = Math.ceil( frames / 2048.0 );\n    const height = lengthCeiled;\n\n    const buffer = new Float32Array( width * height * 4 );\n    const channels = audioBuffer.numberOfChannels;\n\n    const dataL = audioBuffer.getChannelData( 0 );\n    const dataR = audioBuffer.getChannelData( channels === 1 ? 0 : 1 );\n\n    for ( let i = 0; i < frames; i ++ ) {\n      buffer[ i * 4 + 0 ] = dataL[ i ];\n      buffer[ i * 4 + 1 ] = dataR[ i ];\n    }\n\n    const texture = this.__uploadTexture( width, height, buffer );\n\n    const entry = {\n      type: 'sample' as const,\n      width,\n      height,\n      sampleRate,\n      duration,\n      texture,\n    };\n    this.__textures.set( id, entry );\n    return entry;\n  }\n\n  /**\n   * Delete a texture entry.\n   *\n   * Returns a boolean that indicates whether the deletion is successful or not.\n   */\n  public delete( id: string ): boolean {\n    const { gl } = this;\n\n    const texture = this.__textures.get( id );\n    if ( texture == null ) { return false; }\n\n    gl.deleteTexture( texture.texture );\n    this.__textures.delete( id );\n\n    return true;\n  }\n\n  /**\n   * Create a texture and upload data.\n   */\n  private __uploadTexture(\n    width: number,\n    height: number,\n    source: Float32Array,\n  ): WebGLTexture {\n    const { gl } = this;\n\n    const texture = gl.createTexture()!;\n\n    gl.bindTexture( gl.TEXTURE_2D, texture );\n\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      0,\n      gl.RGBA32F,\n      width,\n      height,\n      0,\n      gl.RGBA,\n      gl.FLOAT,\n      source,\n    );\n\n    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\n    gl.bindTexture( gl.TEXTURE_2D, null );\n\n    return texture;\n  }\n\n  /**\n   * Create a texture and upload data.\n   */\n  private __uploadImageSource(\n    source: TexImageSource,\n  ): WebGLTexture {\n    const { gl } = this;\n\n    const texture = gl.createTexture()!;\n\n    gl.bindTexture( gl.TEXTURE_2D, texture );\n\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      0,\n      gl.RGBA8,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      source,\n    );\n\n    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR );\n    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR );\n\n    gl.bindTexture( gl.TEXTURE_2D, null );\n\n    return texture;\n  }\n}\n", "/**\n * `lerp`, or `mix`\n */\nexport function lerp( a: number, b: number, x: number ): number {\n  return a + ( b - a ) * x;\n}\n", "import { Renderer, TFPoolEntry } from './Renderer';\nimport { BeatManager } from './BeatManager';\nimport { BufferReaderNode } from './BufferReaderNode';\nimport { EventEmittable } from './utils/EventEmittable';\nimport { TextureStore } from './TextureStore';\nimport { applyMixins } from './utils/applyMixins';\nimport { lerp } from './utils/lerp';\nimport { shaderchunkPreLines } from './shaderchunks';\n\nconst BLOCK_SIZE = 128;\n\ninterface WavenerdDeckProgram {\n  code: string;\n  requiredTextures: Set<string>;\n}\n\ninterface WavenerdDeckParamEntry {\n  name: string;\n  value: number;\n  factor: number;\n  target: number;\n}\n\nexport class WavenerdDeck {\n  /**\n   * Its host deck.\n   * It's highly recommended to connect the node of the host deck into the node of this deck, to ensure the timing consistency.\n   */\n  public hostDeck?: WavenerdDeck;\n\n  /**\n   * The count of latency blocks.\n   * Block == 128 samples.\n   * Lower == less latency.\n   */\n  public latencyBlocks: number;\n\n  /**\n   * Its current cue status.\n   * `'none'`: There is nothing in its current cue.\n   * `'ready'`: There is a cue shader and is ready to be applied.\n   * `'applying'`: There is a cue shader and is going to be applied in the next bar.\n   */\n  private __cueStatus: 'none' | 'compiling' | 'ready' | 'applying' = 'none';\n\n  /**\n   * Its current cue status.\n   * `'none'`: There is nothing in its current cue.\n   * `'ready'`: There is a cue shader and is ready to be applied.\n   * `'applying'`: There is a cue shader and is going to be applied in the next bar.\n   */\n  public get cueStatus(): 'none' | 'compiling' | 'ready' | 'applying' {\n    return this.__cueStatus;\n  }\n\n  /**\n   * Blocks per a render.\n   */\n  private __blocksPerRender: number;\n\n  /**\n   * Blocks per a render.\n   */\n  public get blocksPerRender(): number {\n    return this.__blocksPerRender;\n  }\n\n  /**\n   * Frames per a render\n   */\n  public get framesPerRender(): number {\n    return BLOCK_SIZE * this.__blocksPerRender;\n  }\n\n  /**\n   * Whether the wavenerd deck is playing or not.\n   */\n  private __isPlaying: boolean;\n\n  /**\n   * Whether the wavenerd deck is playing or not.\n   */\n  public get isPlaying(): boolean {\n    return this.hostDeck?.__isPlaying ?? this.__isPlaying;\n  }\n\n  /**\n   * Its current bpm.\n   */\n  public get bpm(): number {\n    return this.beatManager.bpm;\n  }\n  public set bpm( value: number ) {\n    this.beatManager.bpm = value;\n  }\n\n  /**\n   * Whether it should use `SYNC_GPU_COMMANDS_COMPLETE` or not.\n   */\n  public get useSync(): boolean {\n    return this.__renderer.useSync;\n  }\n  public set useSync( value: boolean ) {\n    this.__renderer.useSync = value;\n  }\n\n  /**\n   * Its last updated time.\n   * Intended to be used for calculation of deltaTime inside (@link __updateUniforms).\n   */\n  private __lastUpdatedTime: number;\n\n  /**\n   * Its renderer.\n   */\n  private __renderer: Renderer;\n\n  /**\n   * Its last compile error happened in [[WavenerdDeck.compile]].\n   */\n  private __lastError: any;\n  public get lastError(): any {\n    return this.__lastError;\n  }\n\n  /**\n   * Its binded `AudioContext`.\n   */\n  private __audio: AudioContext;\n  public get audio(): AudioContext {\n    return this.__audio;\n  }\n\n  /**\n   * Its node of the AudioContext.\n   */\n  private __node: GainNode;\n  public get node(): GainNode {\n    return this.__node;\n  }\n\n  private __bufferReaderNode?: BufferReaderNode;\n  private __bufferWriteBlocks: number;\n\n  /**\n   * Offset of the block compared to {@link __bufferWriteBlocks} in terms of time.\n   * It is used to rewind the deck.\n   */\n  private __blockOffset: number;\n\n  /**\n   * Alias for the `audio.sampleRate` .\n   */\n  public get sampleRate(): number {\n    return this.__audio.sampleRate;\n  }\n\n  private __beatManager: BeatManager;\n  public get beatManager(): BeatManager {\n    const hostDeckBeatManager = this.hostDeck?.beatManager;\n    if ( hostDeckBeatManager ) {\n      return hostDeckBeatManager;\n    }\n\n    return this.__beatManager;\n  }\n\n  private __program: WavenerdDeckProgram | null;\n  private __programCue: WavenerdDeckProgram | null;\n  private __programSwapTime: number | null;\n\n  private __params = new Map<string, WavenerdDeckParamEntry>();\n  private get params(): Map<string, WavenerdDeckParamEntry> {\n    return this.__params;\n  }\n\n  private __selfTextureStore: TextureStore;\n  private get __textureStore(): TextureStore {\n    if ( this.hostDeck ) {\n      return this.hostDeck.__textureStore;\n    }\n\n    return this.__selfTextureStore;\n  }\n\n  /**\n   * Constructor of the WavenerdDeck.\n   */\n  public constructor( {\n    gl,\n    audio,\n    hostDeck,\n    latencyBlocks,\n    blocksPerRender,\n    bpm,\n  }: {\n    gl: WebGL2RenderingContext;\n    audio: AudioContext;\n    hostDeck?: WavenerdDeck;\n    latencyBlocks?: number;\n    blocksPerRender?: number;\n    bpm?: number;\n  } ) {\n    this.__isPlaying = false;\n\n    this.latencyBlocks = latencyBlocks ?? 16;\n    this.__blocksPerRender = blocksPerRender ?? 16;\n\n    // -- host deck --------------------------------------------------------------------------------\n    if ( hostDeck ) {\n      this.hostDeck = hostDeck;\n    }\n\n    // -- beat manager -----------------------------------------------------------------------------\n    this.__beatManager = new BeatManager();\n    this.__beatManager.bpm = bpm ?? 140;\n    this.__beatManager.on( 'changeBPM', ( { bpm } ) => {\n      this.__emit( 'changeBPM', { bpm } );\n    } );\n\n    this.__lastUpdatedTime = 0.0;\n\n    // TODO: temporary solution\n    if ( hostDeck ) {\n      hostDeck.on( 'rewind', () => {\n        this.rewind();\n      } );\n    }\n\n    // -- renderer ---------------------------------------------------------------------------------\n    this.__renderer = new Renderer( gl, this.blocksPerRender );\n\n    this.__selfTextureStore = new TextureStore( gl );\n\n    this.__program = null;\n    this.__programCue = null;\n    this.__programSwapTime = null;\n\n    // -- audio ------------------------------------------------------------------------------------\n    this.__audio = audio;\n    this.__node = audio.createGain();\n\n    BufferReaderNode.addModule( audio ).then( () => {\n      this.__bufferReaderNode = new BufferReaderNode( audio );\n      this.__bufferReaderNode.connect( this.__node );\n    } );\n\n    this.__bufferWriteBlocks = 0;\n    this.__blockOffset = 0;\n  }\n\n  /**\n   * Dispose this WavenerdDeck.\n   */\n  public dispose(): void {\n    this.__setCueStatus( 'none' );\n\n    this.__renderer.dispose();\n    this.__selfTextureStore.dispose();\n\n    this.__bufferReaderNode?.disconnect();\n  }\n\n  /**\n   * Play the deck.\n   */\n  public play(): void {\n    this.__isPlaying = true;\n\n    this.__emit( 'play' );\n  }\n\n  /**\n   * Pause the deck.\n   */\n  public pause(): void {\n    this.__isPlaying = false;\n\n    this.__emit( 'pause' );\n  }\n\n  /**\n   * Rewind the deck.\n   */\n  public rewind(): void {\n    this.__lastUpdatedTime = 0.0;\n    this.__blockOffset = this.__bufferWriteBlocks;\n\n    this.__beatManager.reset();\n\n    this.applyCueImmediately();\n\n    this.__emit( 'rewind' );\n  }\n\n  /**\n   * Compile given shader code and cue the shader.\n   */\n  public async compile( code: string ): Promise<void> {\n    this.__setCueStatus( 'compiling' );\n\n    await this.__renderer.compile( code ).catch( ( e ) => {\n      const error = this.__processErrorMessage( e );\n\n      this.__programCue = null;\n\n      this.__setCueStatus( 'none' );\n\n      this.__emit( 'error', { error } );\n      this.__lastError = error;\n\n      throw new Error( error ?? undefined );\n    } );\n\n    const requiredTextures = new Set<string>();\n\n    for ( const id of this.__textureStore.textureIds ) {\n      if ( code.search( id ) !== -1 ) {\n        requiredTextures.add( id );\n      }\n    }\n\n    this.__programCue = {\n      code,\n      requiredTextures,\n    };\n\n    this.__setCueStatus( 'ready' );\n\n    this.__emit( 'error', { error: null } );\n    this.__lastError = null;\n  }\n\n  /**\n   * Apply the cue shader after the bar ends.\n   */\n  public applyCue(): void {\n    if ( this.__cueStatus === 'ready' ) {\n      this.__setCueStatus( 'applying' );\n\n      this.__programSwapTime =\n        this.beatManager.time - this.beatManager.bar + this.beatManager.barSeconds;\n    }\n  }\n\n  /**\n   * Apply the cue shader immediately.\n   */\n  public applyCueImmediately(): void {\n    if ( this.__programCue != null ) {\n      this.__setCueStatus( 'none' );\n\n      this.__renderer.applyCue();\n\n      this.__program = this.__programCue;\n      this.__programCue = null;\n      this.__programSwapTime = null;\n    }\n  }\n\n  /**\n   * Set a uniform value.\n   */\n  public setParam( name: string, value: number, factor = 50.0 ): void {\n    const param = this.params.get( name );\n    if ( param ) {\n      param.target = value;\n      param.factor = factor;\n    } else {\n      this.params.set( name, { name, target: value, value, factor } );\n    }\n\n    this.__emit( 'setParam', { name, value, factor } );\n  }\n\n  /**\n   * Load a x-y wavetable and store as a uniform texture.\n   * The buffer have to be encoded in F32, 2048 samples per cycle.\n   */\n  public loadWavetable(\n    name: string,\n    inputBuffer: Float32Array,\n  ): void {\n    const id = `wavetable_${ name }`;\n    this.__textureStore.loadWavetable( id, inputBuffer );\n\n    this.__addRequiredTexture( id );\n\n    this.__emit( 'loadWavetable', { name } );\n  }\n\n  /**\n   * Delete a wavetable.\n   */\n  public deleteWavetable( name: string ): void {\n    const isSuccess = this.__textureStore.delete( `wavetable_${ name }` );\n\n    if ( isSuccess ) {\n      this.__emit( 'deleteWavetable', { name } );\n    }\n  }\n\n  /**\n   * Load an image and store as a uniform texture.\n   */\n  public loadImage(\n    name: string,\n    image: TexImageSource,\n  ): void {\n    const id = `image_${ name }`;\n    this.__textureStore.loadImage( id, image );\n\n    this.__addRequiredTexture( id );\n\n    this.__emit( 'loadImage', { name } );\n  }\n\n  /**\n   * Delete an image.\n   */\n  public deleteImage( name: string ): void {\n    const isSuccess = this.__textureStore.delete( `image_${ name }` );\n\n    if ( isSuccess ) {\n      this.__emit( 'deleteImage', { name } );\n    }\n  }\n\n  /**\n   * Load a sample and store as a uniform texture.\n   */\n  public async loadSample( name: string, inputBuffer: ArrayBuffer ): Promise<void> {\n    const audioBuffer = await this.__audio.decodeAudioData( inputBuffer );\n\n    const id = `sample_${ name }`;\n    const { duration, sampleRate } = this.__textureStore.loadSample( id, audioBuffer );\n\n    this.__addRequiredTexture( id );\n\n    this.__emit( 'loadSample', { name, duration, sampleRate } );\n  }\n\n  /**\n   * Delete a sample.\n   */\n  public deleteSample( name: string ): void {\n    const isSuccess = this.__textureStore.delete( `success_${ name }` );\n\n    if ( isSuccess ) {\n      this.__emit( 'deleteSample', { name } );\n    }\n  }\n\n  public async update(): Promise<void> {\n    const bufferReaderNode = this.__bufferReaderNode;\n    if ( bufferReaderNode == null ) { return; }\n\n    const { readBlocks } = bufferReaderNode;\n    const { sampleRate, blocksPerRender, framesPerRender } = this;\n\n    this.__bufferReaderNode?.setActive( this.isPlaying );\n\n    // -- early abort? -----------------------------------------------------------------------------\n    if ( !this.isPlaying ) { return; }\n\n    // -- choose a right write block ---------------------------------------------------------------\n    const blockAhead = this.__bufferWriteBlocks - readBlocks;\n\n    // we don't have to render this time\n    if ( blockAhead > this.latencyBlocks ) {\n      return;\n    }\n\n    // we're very behind\n    if ( blockAhead < 0 ) {\n      this.__bufferWriteBlocks = (\n        Math.floor( readBlocks / blocksPerRender ) + 1\n      ) * blocksPerRender;\n    }\n\n    const genTime = BLOCK_SIZE * ( this.__bufferWriteBlocks - this.__blockOffset ) / sampleRate;\n    this.beatManager.update( genTime );\n\n    // -- should I process the next program? -------------------------------------------------------\n    let beginNext = this.__programSwapTime != null\n      ? Math.floor( ( this.__programSwapTime - genTime ) * sampleRate )\n      : framesPerRender;\n    beginNext = Math.min( beginNext, framesPerRender );\n\n    // -- swap the program from first --------------------------------------------------------------\n    if ( beginNext < 0 ) {\n      this.applyCueImmediately();\n\n      beginNext = framesPerRender;\n    }\n\n    // -- render -----------------------------------------------------------------------------------\n    const tfPoolEntry = this.__renderer.getNextTFPoolEntry();\n\n    if ( this.__program ) {\n      this.__updateUniforms();\n      this.__renderer.render( tfPoolEntry, 0, beginNext );\n    }\n\n    // render the next program from the mid of the block\n    if ( beginNext < framesPerRender && this.__programCue != null ) {\n      this.applyCueImmediately();\n\n      this.__updateUniforms();\n      this.__renderer.render( tfPoolEntry, beginNext, framesPerRender - beginNext );\n    }\n\n    // -- read buffer + update write blocks --------------------------------------------------------\n    this.__readBuffer( tfPoolEntry, this.__bufferWriteBlocks );\n    this.__bufferWriteBlocks += this.blocksPerRender;\n\n    // -- emit an event ----------------------------------------------------------------------------\n    this.__emit( 'update' );\n  }\n\n  private __addRequiredTexture( id: string ): void {\n    if ( this.__program && this.__program.code.search( id ) ) {\n      this.__program.requiredTextures.add( id );\n    }\n\n    if ( this.__programCue && this.__programCue.code.search( id ) ) {\n      this.__programCue.requiredTextures.add( id );\n    }\n  }\n\n  private __updateUniforms(): void {\n    const {\n      time,\n      beatSeconds,\n      barSeconds,\n      sixteenBarSeconds,\n      beat,\n      bar,\n      sixteenBar,\n    } = this.beatManager;\n    const { sampleRate } = this;\n\n    const delta = time - this.__lastUpdatedTime;\n    this.__lastUpdatedTime = time;\n\n    // -- uniforms - params ------------------------------------------------------------------------\n    this.params.forEach( ( param ) => {\n      if ( param.factor <= 0.0 ) {\n        param.value = param.target;\n      } else {\n        param.value = lerp( param.target, param.value, Math.exp( -param.factor * delta ) );\n      }\n\n      this.__renderer.uniform4f(\n        'param_' + param.name,\n        param.target,\n        param.value,\n        param.factor,\n        0.0\n      );\n    } );\n\n    // -- uniforms - samplers ----------------------------------------------------------------------\n    let textureUnit = 0;\n\n    const { requiredTextures } = this.__program!;\n\n    for ( const textureName of requiredTextures ) {\n      const textureEntry = this.__textureStore.get( textureName );\n\n      if ( textureEntry != null ) {\n        this.__renderer.uniformTexture(\n          textureName,\n          textureUnit,\n          textureEntry.texture,\n        );\n        textureUnit ++;\n\n        const meta = (\n          textureEntry.type === 'sample'\n            ? [\n              textureEntry.width,\n              textureEntry.height,\n              textureEntry.sampleRate,\n              textureEntry.duration,\n            ]\n            : [\n              textureEntry.width,\n              textureEntry.height,\n              0,\n              0,\n            ]\n        ) as [ number, number, number, number ];\n\n        this.__renderer.uniform4f(\n          textureName + '_meta',\n          ...meta,\n        );\n      }\n    }\n\n    // -- uniforms - others ------------------------------------------------------------------------\n    this.__renderer.uniform1f( 'bpm', this.bpm );\n    this.__renderer.uniform1f( '_deltaSample', 1.0 / sampleRate );\n    this.__renderer.uniform4f(\n      'timeLength',\n      beatSeconds,\n      barSeconds,\n      sixteenBarSeconds,\n      1E16\n    );\n    this.__renderer.uniform4f(\n      '_timeHead',\n      beat,\n      bar,\n      sixteenBar,\n      time\n    );\n  }\n\n  private async __readBuffer( tfPoolEntry: TFPoolEntry, bufferWriteBlocks: number ): Promise<void> {\n    const bufferReaderNode = this.__bufferReaderNode;\n    if ( bufferReaderNode == null ) { return; }\n\n    await this.__renderer.readBuffer( tfPoolEntry );\n\n    bufferReaderNode.write(\n      0,\n      bufferWriteBlocks,\n      0,\n      tfPoolEntry.dstArrays[ 0 ].subarray( 0, this.framesPerRender ),\n    );\n\n    bufferReaderNode.write(\n      1,\n      bufferWriteBlocks,\n      0,\n      tfPoolEntry.dstArrays[ 1 ].subarray( 0, this.framesPerRender ),\n    );\n  }\n\n  private __setCueStatus( cueStatus: 'none' | 'compiling' | 'ready' | 'applying' ): void {\n    this.__cueStatus = cueStatus;\n    this.__emit( 'changeCueStatus', { cueStatus } );\n  }\n\n  private __processErrorMessage( error: any ): string | null {\n    const str: string | undefined = error?.message ?? error;\n    if ( !str ) { return null; }\n\n    return str.replace( /ERROR: (\\d+):(\\d+)/g, ( match, ...args ) => {\n      const line = parseInt( args[ 1 ] ) - shaderchunkPreLines + 1;\n      return `ERROR: ${ args[ 0 ] }:${ line }`;\n    } );\n  }\n}\n\nexport interface WavenerdDeck extends EventEmittable<{\n  update: void;\n  play: void;\n  pause: void;\n  rewind: void;\n  changeCueStatus: { cueStatus: 'none' | 'compiling' | 'ready' | 'applying' };\n  setParam: { name: string; value: number; factor: number };\n  loadWavetable: { name: string };\n  deleteWavetable: { name: string };\n  loadImage: { name: string };\n  deleteImage: { name: string };\n  loadSample: { name: string; sampleRate: number; duration: number };\n  deleteSample: { name: string };\n  changeBPM: { bpm: number };\n  error: { error: string | null };\n}> {}\napplyMixins( WavenerdDeck, [ EventEmittable ] );\n"],
  "mappings": "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",
  "names": []
}
