export declare const shaderchunkPre = "#version 300 es\n\nprecision highp float;\n\n#define _PI 3.14159265359\n\nuniform float bpm;\nuniform vec4 timeLength;\nuniform float sampleRate;\nuniform float _deltaSample;\nuniform vec4 _timeHead;\n\nin float off;\n\nout float outL;\nout float outR;\n\nfloat paramFetch( vec4 param ) {\n  return mix( param.x, param.y, exp( -param.z * off * _deltaSample ) );\n}\n\nvec2 sampleNearest( sampler2D s, vec4 meta, float time ) {\n  if ( meta.w < time ) { return vec2( 0.0 ); }\n  float x = time / meta.x * meta.z;\n  vec2 uv = fract( vec2(\n    x,\n    floor( x ) / meta.y\n  ) ) + 0.5 / meta.xy;\n  return texture( s, uv ).xy;\n}\n\n// I have 0% confidence that the algorithm is perfect\nvec2 sampleSinc( sampler2D s, vec4 meta, float time ) {\n  if ( meta.w < time ) { return vec2( 0.0 ); }\n  vec2 sum = vec2( 0.0 );\n  float def = 0.5 - fract( time * meta.z );\n  for ( int i = -5; i <= 5; i ++ ) {\n    float x = floor( time * meta.z + float( i ) ) / meta.x;\n    float deft = def + float( i );\n    vec2 uv = fract( vec2(\n      x,\n      floor( x ) / meta.y\n    ) ) + 0.5 / meta.xy;\n    sum += texture( s, uv ).xy * min( sin( deft * _PI ) / deft / _PI, 1.0 );\n  }\n  return sum;\n}\n";
export declare const shaderchunkPreLines: number;
export declare const shaderchunkPost = "void main() {\n  vec2 out2 = mainAudio( mod( _timeHead + off * _deltaSample, timeLength ) );\n  outL = out2.x;\n  outR = out2.y;\n}";
