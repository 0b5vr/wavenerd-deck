export declare const shaderchunkPre = "precision highp float;\n\n#define _PI 3.14159265359\n\nuniform float bpm;\nuniform vec4 timeLength;\nuniform float sampleRate;\nuniform float _deltaSample;\nuniform float _deltaChunk;\nuniform vec4 _timeHead;\n\nvec2 sampleNearest( sampler2D s, vec4 meta, float time ) {\n  if ( meta.w < time ) { return vec2( 0.0 ); }\n  float x = time / meta.x * meta.z;\n  vec2 uv = fract( vec2(\n    x,\n    floor( x ) / meta.y\n  ) ) + 0.5 / meta.xy;\n  return texture2D( s, uv ).xy;\n}\n\n// I have 0% confidence that the algorithm is perfect\nvec2 sample( sampler2D s, vec4 meta, float time ) {\n  if ( meta.w < time ) { return vec2( 0.0 ); }\n  vec2 sum = vec2( 0.0 );\n  float def = 0.5 - fract( time * meta.z );\n  for ( int i = -5; i <= 5; i ++ ) {\n    float x = floor( time * meta.z + float( i ) ) / meta.x;\n    float deft = def + float( i );\n    vec2 uv = fract( vec2(\n      x,\n      floor( x ) / meta.y\n    ) ) + 0.5 / meta.xy;\n    sum += texture2D( s, uv ).xy * min( sin( deft * _PI ) / deft / _PI, 1.0 );\n  }\n  return sum;\n}\n";
export declare const shaderchunkPreLines: number;
export declare const shaderchunkPost = "void main() {\n  float off = floor( gl_FragCoord.x ) * 2.0;\n  vec4 head = _timeHead + _deltaChunk * floor( gl_FragCoord.y );\n  gl_FragColor = vec4(\n    mainAudio( mod( head + ( off ) * _deltaSample, timeLength ) ),\n    mainAudio( mod( head + ( off + 1.0 ) * _deltaSample, timeLength ) )\n  );\n}";
