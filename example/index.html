<!DOCTYPE html>

<body>
  <textarea cols="100" rows="40" id="textarea">
  </textarea><br />
  BPM: <input id="inputBpm" type="number" value="190" /><br />
  <button id="buttonCompile">Compile</button>
  <button id="buttonApplyCue" disabled>Apply Cue</button><br />
  <span id="spanStatus">Awaiting cue</span><br />
  <input id="inputUniformKnob" type="range" step="0.001" min="0" max="1" value="0" /> Knob
</body>

<script type="module">
  import { WavenerdDeck } from '../dist/wavenerd-deck.esm.js';
  import { fetchImage } from './fetchImage.js';

  ( async () => {
    const canvas = document.createElement( 'canvas' );
    const gl = canvas.getContext( 'webgl2' );

    const audio = new AudioContext();

    const wavenerdDeck = new WavenerdDeck( { gl, audio } );
    wavenerdDeck.bpm = 190;

    const splitter = audio.createChannelSplitter( 4 );
    const mergerOut = audio.createChannelMerger( 2 );
    const mergerSend = audio.createChannelMerger( 2 );
    const convolver = audio.createConvolver();

    wavenerdDeck.node.connect( splitter );
    splitter.connect( mergerOut, 0, 0 );
    splitter.connect( mergerOut, 1, 1 );
    splitter.connect( mergerSend, 2, 0 );
    splitter.connect( mergerSend, 3, 1 );
    mergerOut.connect( audio.destination );
    mergerSend.connect( convolver );
    convolver.connect( audio.destination );

    await fetch( './ir.wav' )
      .then( ( res ) => res.arrayBuffer() )
      .then( ( raw ) => audio.decodeAudioData( raw ) )
      .then( ( buffer ) => {
        convolver.buffer = buffer;
      } );

    await fetch( './wavetables/m-talk.bin' )
      .then( ( res ) => res.arrayBuffer() )
      .then( ( buffer ) => wavenerdDeck.loadWavetable( 'mtalk', new Float32Array( buffer ) ) )

    await fetchImage( './images/fbm.png' )
      .then( ( image ) => wavenerdDeck.loadImage( 'fbm', image ) );

    await fetch( './samples/amen.ogg' )
      .then( ( res ) => res.arrayBuffer() )
      .then( ( buffer ) => wavenerdDeck.loadSample( 'amen', buffer ) );

    await fetch( './samples/crash.ogg' )
      .then( ( res ) => res.arrayBuffer() )
      .then( ( buffer ) => wavenerdDeck.loadSample( 'crash', buffer ) );

    await fetch( './samples/909oh.ogg' )
      .then( ( res ) => res.arrayBuffer() )
      .then( ( buffer ) => wavenerdDeck.loadSample( '909oh', buffer ) );

    const frag = await fetch( './example.frag' )
      .then( ( res ) => res.text() );

    textarea.value = frag;

    wavenerdDeck.compile( frag );

    // == update wavenerd ============================================================================
    function update() {
      wavenerdDeck.update();
      requestAnimationFrame( update );
    }
    requestAnimationFrame( update );

    // == wavenerd deck event listeners ==============================================================
    wavenerdDeck.on( 'changeCueStatus', ( { cueStatus } ) => {
      buttonApplyCue.disabled = cueStatus !== 'ready';

      spanStatus.innerText = (
        cueStatus === 'none' ? 'Awaiting cue' :
        cueStatus === 'compiling' ? 'Compiling' :
        cueStatus === 'ready' ? 'Ready' :
        'Applying...'
      )
    } );

    // == ui listeners ===============================================================================
    inputBpm.addEventListener( 'change', () => {
      wavenerdDeck.bpm = inputBpm.value;
    } );

    buttonCompile.addEventListener( 'click', () => {
      audio.resume(); // uh
      wavenerdDeck.compile( textarea.value );
    } );

    buttonApplyCue.addEventListener( 'click', () => {
      audio.resume(); // uh
      wavenerdDeck.applyCue();
    } );

    inputUniformKnob.addEventListener( 'input', () => {
      wavenerdDeck.setParam( 'knob', parseFloat( inputUniformKnob.value ) );
    } );
  } )();
</script>
